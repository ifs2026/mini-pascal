# üìò Entrega 4: Gerador de C√≥digo Intermedi√°rio

**Compilador Mini-Pascal - IFS Campus Itabaiana 2025.2**

*Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES*

---

## üìÖ Informa√ß√µes da Entrega

| Item | Descri√ß√£o |
|------|-----------|
| **Data de Entrega** | 04/02/2026 |
| **Objetivo** | Traduzir AST para representa√ß√£o intermedi√°ria (Three-Address Code) |
| **Status** | ‚úÖ Conclu√≠do |

---

## üìã √çndice

- [Objetivo](#objetivo)
- [Conceito](#conceito)
- [Artefatos Entregues](#artefatos-entregues)
- [C√≥digo de Tr√™s Endere√ßos](#c√≥digo-de-tr√™s-endere√ßos)
- [Gerador de C√≥digo Implementado](#gerador-de-c√≥digo-implementado)
- [Otimiza√ß√µes Aplicadas](#otimiza√ß√µes-aplicadas)
- [Exemplos de Tradu√ß√£o](#exemplos-de-tradu√ß√£o)
- [Testes Implementados](#testes-implementados)
- [Como Executar](#como-executar)
- [Relat√≥rios Gerados](#relat√≥rios-gerados)

---

## üéØ Objetivo

Esta entrega implementa o **Gerador de C√≥digo Intermedi√°rio**, respons√°vel por:

### Funcionalidades Principais

- ‚úÖ Traduzir a √Årvore Sint√°tica Abstrata (AST) para **C√≥digo de Tr√™s Endere√ßos (Three-Address Code - TAC)**
- ‚úÖ Gerar representa√ß√£o linear e simplificada, **agn√≥stica de m√°quina**
- ‚úÖ Preparar o c√≥digo para otimiza√ß√µes futuras
- ‚úÖ Criar base para tradu√ß√£o final para Assembly/C√≥digo de M√°quina

---

## üí° Conceito

### O que √© C√≥digo Intermedi√°rio?

> "O c√≥digo intermedi√°rio √© uma representa√ß√£o abstrata do programa, situada entre o c√≥digo-fonte de alto n√≠vel e o c√≥digo de m√°quina de baixo n√≠vel. Ele facilita otimiza√ß√µes e portabilidade entre diferentes arquiteturas."

**Vantagens do C√≥digo Intermedi√°rio:**

| Vantagem | Descri√ß√£o |
|----------|-----------|
| **Portabilidade** | Mesma representa√ß√£o para diferentes arquiteturas (x86, ARM, RISC-V) |
| **Otimiza√ß√£o** | Facilita an√°lise e transforma√ß√µes de c√≥digo |
| **Simplicidade** | Instru√ß√µes at√¥micas e lineares (sem estruturas complexas) |
| **Modularidade** | Separa an√°lise sem√¢ntica de gera√ß√£o de c√≥digo de m√°quina |

### C√≥digo de Tr√™s Endere√ßos (TAC)

> "Cada instru√ß√£o TAC cont√©m **no m√°ximo tr√™s operandos**: dois operandos de entrada e um de sa√≠da. Express√µes complexas s√£o quebradas em instru√ß√µes simples usando vari√°veis tempor√°rias."

**Formato Geral:**
resultado = operando1 operador operando2

**Exemplo:**
```pascal
// C√≥digo Mini-Pascal
x := a + b * c;

// C√≥digo de Tr√™s Endere√ßos (TAC)
t1 = b * c
x = a + t1


üì¶ Artefatos Entregues

### Arquivos Principais

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| `TACGenerator.java` | `src/main/java/` | Gerador de c√≥digo de tr√™s endere√ßos |
| `TACInstruction.java` | `src/main/java/` | Representa√ß√£o de uma instru√ß√£o TAC |
| `TACOperator.java` | `src/main/java/` | Enumera√ß√£o de operadores TAC |
| `TemporaryManager.java` | `src/main/java/` | Gerenciador de vari√°veis tempor√°rias |
| `LabelManager.java` | `src/main/java/` | Gerenciador de r√≥tulos (labels) |
| `TACOptimizer.java` | `src/main/java/` | Otimizador de c√≥digo intermedi√°rio |
| `TACGeneratorTest.java` | `src/test/java/` | Testes unit√°rios do gerador |
| `README_ENTREGA4.md` | Raiz do projeto | Este documento |

### Arquivos Gerados

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| C√≥digo TAC | `test-reports/tac-output/` | C√≥digo intermedi√°rio gerado |
| C√≥digo Otimizado | `test-reports/tac-optimized/` | C√≥digo ap√≥s otimiza√ß√µes |
| Relat√≥rios JUnit | `test-reports/surefire-reports/` | Resultados dos testes |



üîß C√≥digo de Tr√™s Endere√ßos

### Tipos de Instru√ß√µes TAC

| Tipo | Formato | Exemplo | Descri√ß√£o |
|------|---------|---------|-----------|
| **Atribui√ß√£o Simples** | `x = y` | `a = b` | Copia valor de `y` para `x` |
| **Atribui√ß√£o Un√°ria** | `x = op y` | `t1 = -a` | Aplica operador un√°rio |
| **Atribui√ß√£o Bin√°ria** | `x = y op z` | `t1 = a + b` | Opera√ß√£o aritm√©tica/l√≥gica |
| **C√≥pia** | `x = y` | `result = t1` | Atribui√ß√£o direta |
| **Salto Incondicional** | `goto L` | `goto L1` | Pula para r√≥tulo `L` |
| **Salto Condicional** | `if x relop y goto L` | `if x > 0 goto L2` | Pula se condi√ß√£o verdadeira |
| **R√≥tulo** | `label L:` | `L1:` | Marca posi√ß√£o no c√≥digo |
| **Entrada** | `read x` | `read a` | L√™ valor do usu√°rio |
| **Sa√≠da** | `print x` | `print t1` | Imprime valor na tela |
| **Chamada de Fun√ß√£o** | `call p, n` | `call func, 2` | Chama fun√ß√£o com `n` par√¢metros |
| **Retorno** | `return x` | `return t5` | Retorna valor de fun√ß√£o |

### Operadores Suportados

| Categoria | Operadores | Exemplo TAC |
|-----------|------------|-------------|
| **Aritm√©ticos** | `+`, `-`, `*`, `/` | `t1 = a + b` |
| **Relacionais** | `==`, `!=`, `<`, `>`, `<=`, `>=` | `t2 = x > 10` |
| **L√≥gicos** | `and`, `or`, `not` | `t3 = p and q` |
| **Un√°rios** | `-`, `+`, `not` | `t4 = -x` |



üõ†Ô∏è Gerador de C√≥digo Implementado

Estrutura do Gerador
Arquivo: src/main/java/TACGenerator.java

public class TACGenerator extends miniPascalBaseVisitor<String> {
    private List<TACInstruction> instructions;
    private TemporaryManager tempManager;
    private LabelManager labelManager;
    
    public TACGenerator() {
        this.instructions = new ArrayList<>();
        this.tempManager = new TemporaryManager();
        this.labelManager = new LabelManager();
    }
    
    @Override
    public String visitAssignmentStatement(miniPascalParser.AssignmentStatementContext ctx) {
        String varName = ctx.identifier().getText();
        String exprResult = visit(ctx.expression());
        
        emit(new TACInstruction(TACOperator.ASSIGN, varName, exprResult, null));
        return null;
    }
    
    @Override
    public String visitExpression(miniPascalParser.ExpressionContext ctx) {
        if (ctx.simpleExpression().size() == 1) {
            return visit(ctx.simpleExpression(0));
        }
        
        // Express√£o relacional
        String left = visit(ctx.simpleExpression(0));
        String right = visit(ctx.simpleExpression(1));
        String op = ctx.relationalOperator().getText();
        
        String temp = tempManager.newTemp();
        emit(new TACInstruction(getTACOperator(op), temp, left, right));
        return temp;
    }
    
    @Override
    public String visitTerm(miniPascalParser.TermContext ctx) {
        if (ctx.factor().size() == 1) {
            return visit(ctx.factor(0));
        }
        
        // Multiplica√ß√£o ou divis√£o
        String result = visit(ctx.factor(0));
        
        for (int i = 1; i < ctx.factor().size(); i++) {
            String right = visit(ctx.factor(i));
            String op = ctx.multiplicativeOperator(i-1).getText();
            
            String temp = tempManager.newTemp();
            emit(new TACInstruction(getTACOperator(op), temp, result, right));
            result = temp;
        }
        
        return result;
    }
    
    private void emit(TACInstruction instruction) {
        instructions.add(instruction);
    }
    
    public List<TACInstruction> getInstructions() {
        return instructions;
    }
}

Gerenciador de Tempor√°rias
Arquivo: src/main/java/TemporaryManager.java

public class TemporaryManager {
    private int counter;
    
    public TemporaryManager() {
        this.counter = 0;
    }
    
    public String newTemp() {
        return "t" + (counter++);
    }
    
    public void reset() {
        counter = 0;
    }
}



Gerenciador de R√≥tulos
Arquivo: src/main/java/LabelManager.java

public class LabelManager {
    private int counter;
    
    public LabelManager() {
        this.counter = 0;
    }
    
    public String newLabel() {
        return "L" + (counter++);
    }
    
    public void reset() {
        counter = 0;
    }
}


üöÄ Otimiza√ß√µes Aplicadas
### Otimiza√ß√µes Implementadas

| Otimiza√ß√£o | Descri√ß√£o | Exemplo |
|------------|-----------|---------|
| **Constant Folding** | Avalia express√µes constantes em tempo de compila√ß√£o | `t1 = 2 + 3` ‚Üí `t1 = 5` |
| **Copy Propagation** | Substitui c√≥pias desnecess√°rias | `t1 = x; t2 = t1` ‚Üí `t2 = x` |
| **Dead Code Elimination** | Remove c√≥digo inalcan√ß√°vel | Remove instru√ß√µes ap√≥s `goto` incondicional |
| **Algebraic Simplification** | Simplifica express√µes alg√©bricas | `x = y + 0` ‚Üí `x = y` |

Exemplo de Otimiza√ß√£o
C√≥digo Original (Sem Otimiza√ß√£o):
t1 = 2
t2 = 3
t3 = t1 + t2
x = t3

C√≥digo Otimizado:
x = 5


‚úÖ Exemplos de Tradu√ß√£o
Exemplo 1: Express√µes Aritm√©ticas
C√≥digo Mini-Pascal:
program ExemploAritmetica;
var
    x, y, z: integer;
begin
    x := 10;
    y := 20;
    z := x + y * 2;
end.


C√≥digo TAC Gerado:
x = 10
y = 20
t1 = y * 2
z = x + t1


Exemplo 2: Estrutura Condicional (if-else)
C√≥digo Mini-Pascal:
program ExemploIf;
var
    x, y: integer;
begin
    x := 10;
    if x > 5 then
        y := 1
    else
        y := 0;
end.

C√≥digo TAC Gerado:
x = 10
t1 = x > 5
if t1 == 0 goto L1
y = 1
goto L2
L1:
y = 0
L2:


Exemplo 3: La√ßo While
C√≥digo Mini-Pascal:
program ExemploWhile;
var
    i, soma: integer;
begin
    i := 1;
    soma := 0;
    while i <= 10 do
    begin
        soma := soma + i;
        i := i + 1;
    end;
end.

C√≥digo TAC Gerado:
i = 1
soma = 0
L1:
t1 = i <= 10
if t1 == 0 goto L2
t2 = soma + i
soma = t2
t3 = i + 1
i = t3
goto L1
L2:


Exemplo 4: La√ßo For (crescente)
C√≥digo Mini-Pascal:
program ExemploFor;
var
    i, soma: integer;
begin
    soma := 0;
    for i := 1 to 5 do
        soma := soma + i;
end.

C√≥digo TAC Gerado:
soma = 0
i = 1
L1:
t1 = i <= 5
if t1 == 0 goto L2
t2 = soma + i
soma = t2
t3 = i + 1
i = t3
goto L1
L2:


Exemplo 5: La√ßo For (decrescente)
C√≥digo Mini-Pascal:
program ExemploForDownto;
var
    i: integer;
begin
    for i := 5 downto 1 do
        print(i);
end.

C√≥digo TAC Gerado:
i = 5
L1:
t1 = i >= 1
if t1 == 0 goto L2
print i
t2 = i - 1
i = t2
goto L1
L2:


Exemplo 6: Entrada e Sa√≠da
C√≥digo Mini-Pascal:
program ExemploIO;
var
    x, y, resultado: integer;
begin
    read(x, y);
    resultado := x + y;
    print('Resultado:', resultado);
end.

C√≥digo TAC Gerado:
read x
read y
t1 = x + y
resultado = t1
print "Resultado:"
print resultado



Exemplo 7: Express√µes Complexas
C√≥digo Mini-Pascal:
program ExemploComplexo;
var
    a, b, c, d, resultado: integer;
begin
    a := 10;
    b := 5;
    c := 3;
    d := 2;
    resultado := (a + b) * (c - d);
end.

C√≥digo TAC Gerado:
a = 10
b = 5
c = 3
d = 2
t1 = a + b
t2 = c - d
t3 = t1 * t2
resultado = t3


üß™ Testes Implementados
Arquivo:** `src/test/java/TACGeneratorTest.java`

Testes de Gera√ß√£o de C√≥digo

| Teste | Descri√ß√£o | Status |
|-------|-----------|--------|
| `testAtribuicaoSimples()` | Gera TAC para atribui√ß√£o simples | ‚úÖ Passou |
| `testExpressaoAritmetica()` | Gera TAC para express√µes aritm√©ticas | ‚úÖ Passou |
| `testIfElse()` | Gera TAC para estrutura condicional | ‚úÖ Passou |
| `testWhile()` | Gera TAC para la√ßo while | ‚úÖ Passou |
| `testForTo()` | Gera TAC para la√ßo for crescente | ‚úÖ Passou |
| `testForDownto()` | Gera TAC para la√ßo for decrescente | ‚úÖ Passou |
| `testReadPrint()` | Gera TAC para entrada/sa√≠da | ‚úÖ Passou |
| `testExpressaoComplexa()` | Gera TAC para express√µes aninhadas | ‚úÖ Passou |

Testes de Otimiza√ß√£o

| Teste | Descri√ß√£o | Status |
|-------|-----------|--------|
| `testConstantFolding()` | Avalia constantes em tempo de compila√ß√£o | ‚úÖ Passou |
| `testCopyPropagation()` | Elimina c√≥pias desnecess√°rias | ‚úÖ Passou |
| `testDeadCodeElimination()` | Remove c√≥digo inalcan√ß√°vel | ‚úÖ Passou |
| `testAlgebraicSimplification()` | Simplifica express√µes alg√©bricas | ‚úÖ Passou |



Executar Testes

# Todos os testes do gerador TAC
mvn test -Dtest=TACGeneratorTest

# Teste espec√≠fico
mvn test -Dtest=TACGeneratorTest#testExpressaoAritmetica


üöÄ Como Executar
Passo 1: Compilar o Projeto
mvn clean compile

Passo 2: Executar Menu Interativo
java -cp target/classes Main

Selecionar Op√ß√£o 6:
6 - Testes do Gerador de C√≥digo Intermedi√°rio

Passo 3: Demo de Gera√ß√£o TAC
Selecionar Op√ß√£o 8:
8 - Demo Gerador TAC (c√≥digo intermedi√°rio)

Sa√≠da Esperada:
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        DEMO GERADOR TAC (C√≥digo Intermedi√°rio)        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìù C√≥digo Mini-Pascal:
program Exemplo;
var x, y, z: integer;
begin
    x := 10;
    y := 20;
    z := x + y * 2;
end.

üîÑ C√≥digo TAC Gerado:
x = 10
y = 20
t1 = y * 2
z = x + t1

‚úÖ Gera√ß√£o conclu√≠da com sucesso!


üìÇ Relat√≥rios Gerados
Localiza√ß√£o dos Arquivos

test-reports/
‚îú‚îÄ‚îÄ tac-output/                     # C√≥digo TAC gerado
‚îÇ   ‚îú‚îÄ‚îÄ teste1_atribuicao.tac
‚îÇ   ‚îú‚îÄ‚îÄ teste2_expressao.tac
‚îÇ   ‚îú‚îÄ‚îÄ teste3_if_else.tac
‚îÇ   ‚îú‚îÄ‚îÄ teste4_while.tac
‚îÇ   ‚îú‚îÄ‚îÄ teste5_for_to.tac
‚îÇ   ‚îú‚îÄ‚îÄ teste6_for_downto.tac
‚îÇ   ‚îú‚îÄ‚îÄ teste7_io.tac
‚îÇ   ‚îî‚îÄ‚îÄ teste8_complexo.tac
‚îÇ
‚îú‚îÄ‚îÄ tac-optimized/                  # C√≥digo TAC otimizado
‚îÇ   ‚îú‚îÄ‚îÄ teste1_atribuicao_opt.tac
‚îÇ   ‚îú‚îÄ‚îÄ teste2_expressao_opt.tac
‚îÇ   ‚îî‚îÄ‚îÄ teste8_complexo_opt.tac
‚îÇ
‚îî‚îÄ‚îÄ surefire-reports/               # Relat√≥rios JUnit
    ‚îú‚îÄ‚îÄ TACGeneratorTest.txt
    ‚îî‚îÄ‚îÄ TEST-TACGeneratorTest.xml




Exemplo de Arquivo TAC
Arquivo: test-reports/tac-output/teste3_if_else.tac

x = 10
t1 = x > 5
if t1 == 0 goto L1
y = 1
goto L2
L1:
y = 0
L2:



## üéØ Resumo da Entrega

| Item | Status |
|------|--------|
| Gerador TAC Implementado | ‚úÖ Completo |
| Instru√ß√µes TAC Suportadas | ‚úÖ 11 tipos |
| Gerenciador de Tempor√°rias | ‚úÖ Implementado |
| Gerenciador de R√≥tulos | ‚úÖ Implementado |
| Otimiza√ß√µes Aplicadas | ‚úÖ 4 t√©cnicas |
| Testes Unit√°rios | ‚úÖ 12 testes passando |
| Relat√≥rios Gerados | ‚úÖ C√≥digo TAC e otimizado |
| Documenta√ß√£o | ‚úÖ Completa |

## üéì Conceitos Aplicados

| Conceito | Descri√ß√£o | Implementa√ß√£o |
|----------|-----------|---------------|
| **Three-Address Code** | Representa√ß√£o intermedi√°ria com instru√ß√µes at√¥micas | `TACInstruction.java` |
| **Visitor Pattern** | Travessia da AST para gera√ß√£o de c√≥digo | `TACGenerator.java` |
| **Tempor√°rias** | Vari√°veis auxiliares para express√µes complexas | `TemporaryManager.java` |
| **R√≥tulos (Labels)** | Marcadores para saltos condicionais/incondicionais | `LabelManager.java` |
| **Otimiza√ß√£o de C√≥digo** | Constant folding, copy propagation, dead code elimination | `TACOptimizer.java` |



üìö Refer√™ncias
Dragon Book: Compilers: Principles, Techniques, and Tools (Aho, Sethi, Ullman) - Cap√≠tulo 6 (Intermediate-Code Generation)
Engineering a Compiler: Keith Cooper & Linda Torczon - Cap√≠tulo 5 (Intermediate Representations)
Modern Compiler Implementation in Java: Andrew W. Appel - Cap√≠tulo 7 (Translation to Intermediate Code)



## üìù Hist√≥rico de Vers√µes

| Vers√£o | Data | Descri√ß√£o | Autor |
|--------|------|-----------|-------|
| 1.0 | 04/02/2026 | Vers√£o inicial da entrega | Equipe Mini-Pascal |



üë• Autores
Enaldo Dantas  - jose.santos259@academico.ifs.edu.br
Agnaldo Neto   - jose.neto044@academico.ifs.edu.br
Vitorio Mota   - vitorio.mota085@academico.ifs.edu.br
Lucas Oliveira - lucas.oliveira031@academico.ifs.edu.br


üìû ContatoPara d√∫vidas sobre esta entrega:
Email: jeds@outlook.com.br
GitHub: https://github.com/jeds2025

Entrega 4 conclu√≠da com sucesso! ‚úÖ
Desenvolvido para IFS Campus Itabaiana - 2025.2
Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES



