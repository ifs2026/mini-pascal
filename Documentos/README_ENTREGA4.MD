# üìò Entrega 4: Gerador de C√≥digo Intermedi√°rio

**Compilador Mini-Pascal - IFS Campus Itabaiana 2025.2**

*Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES*

---

## üìÖ Informa√ß√µes da Entrega

| Item | Descri√ß√£o |
|------|-----------|
| **Data de Entrega** | 04/02/2026 |
| **Objetivo** | Traduzir AST para representa√ß√£o intermedi√°ria (Three-Address Code) |
| **Status** | ‚úÖ Conclu√≠do |

---

## üìã √çndice

- [Objetivo](#objetivo)
- [Conceito](#conceito)
- [Artefatos Entregues](#artefatos-entregues)
- [C√≥digo de Tr√™s Endere√ßos](#c√≥digo-de-tr√™s-endere√ßos)
- [Gerador de C√≥digo Implementado](#gerador-de-c√≥digo-implementado)
- [Otimiza√ß√µes Aplicadas](#otimiza√ß√µes-aplicadas)
- [Exemplos de Tradu√ß√£o](#exemplos-de-tradu√ß√£o)
- [Testes Implementados](#testes-implementados)
- [Como Executar](#como-executar)
- [Relat√≥rios Gerados](#relat√≥rios-gerados)

---

## üéØ Objetivo

Esta entrega implementa o **Gerador de C√≥digo Intermedi√°rio**, respons√°vel por:

### Funcionalidades Principais

- ‚úÖ Traduzir a √Årvore Sint√°tica Abstrata (AST) para **C√≥digo de Tr√™s Endere√ßos (Three-Address Code - TAC)**.
- ‚úÖ Gerar representa√ß√£o linear e simplificada, **agn√≥stica de m√°quina**.
- ‚úÖ Preparar o c√≥digo para otimiza√ß√µes futuras.
- ‚úÖ Criar base para tradu√ß√£o final para Assembly/C√≥digo de M√°quina.

---

## üí° Conceito

### O que √© C√≥digo Intermedi√°rio?

> "O c√≥digo intermedi√°rio √© uma representa√ß√£o abstrata do programa, situada entre o c√≥digo-fonte de alto n√≠vel e o c√≥digo de m√°quina de baixo n√≠vel. Ele facilita otimiza√ß√µes e portabilidade entre diferentes arquiteturas."

**Vantagens do C√≥digo Intermedi√°rio:**

| Vantagem | Descri√ß√£o |
|----------|-----------|
| **Portabilidade** | Mesma representa√ß√£o para diferentes arquiteturas (x86, ARM, RISC-V). |
| **Otimiza√ß√£o** | Facilita a an√°lise e transforma√ß√µes de c√≥digo para ganho de performance. |
| **Simplicidade** | Instru√ß√µes at√¥micas e lineares, sem estruturas de controle complexas. |
| **Modularidade** | Separa a an√°lise sem√¢ntica da gera√ß√£o de c√≥digo de m√°quina final. |

### C√≥digo de Tr√™s Endere√ßos (TAC)

Cada instru√ß√£o TAC cont√©m **no m√°ximo tr√™s operandos**: dois operandos de entrada e um de sa√≠da. Express√µes complexas s√£o quebradas em instru√ß√µes simples usando vari√°veis tempor√°rias.

**Formato Geral:**
`resultado = operando1 operador operando2`

**Exemplo:**
```pascal
// C√≥digo Mini-Pascal
x := a + b * c;

// C√≥digo de Tr√™s Endere√ßos (TAC)
t0 = b * c
t1 = a + t0
x = t1


üì¶ Artefatos Entregues
### Arquivos Principais

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
| :--- | :--- | :--- |
| `MiniPascalCodeGenerator.java` | `src/main/java/` | Gerador de c√≥digo (Visitor) que traduz a AST para TAC. |
| `Instruction.java` | `src/main/java/` | Representa√ß√£o de uma instru√ß√£o TAC (result, arg1, op, arg2). |
| `Main.java` | `src/main/java/` | Ponto de entrada com menu interativo atualizado. |
| `README_ENTREGA4.md` | Raiz do projeto | Este documento de documenta√ß√£o. |

### Arquivos Gerados (Evid√™ncias)

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
| :--- | :--- | :--- |
| `teste1_output.tac` | `test-reports/tac-output/` | C√≥digo TAC gerado para express√µes aritm√©ticas. |
| `teste2_output.tac` | `test-reports/tac-output/` | C√≥digo TAC gerado para estruturas If-Else. |
| `teste3_output.tac` | `test-reports/tac-output/` | C√≥digo TAC gerado para la√ßos While. |

üîß C√≥digo de Tr√™s Endere√ßos
### Tipos de Instru√ß√µes TAC Suportadas

| Tipo | Formato | Exemplo | Descri√ß√£o |
| :--- | :--- | :--- | :--- |
| **Atribui√ß√£o Bin√°ria** | `x = y op z` | `t1 = a + b` | Opera√ß√µes aritm√©ticas, l√≥gicas e relacionais. |
| **Atribui√ß√£o Un√°ria** | `x = op y` | `t1 = not a` | Operadores `NOT`, `+` e `-` un√°rios. |
| **C√≥pia (Simples)** | `x = y` | `x = t1` | Atribui√ß√£o direta de valor ou vari√°vel. |
| **Salto Incondicional** | `goto L` | `goto L1` | Desvio direto para um r√≥tulo. |
| **Salto Condicional** | `if x goto L` | `if t0 goto L2` | Pula para o r√≥tulo se a condi√ß√£o for verdadeira. |
| **R√≥tulo (Label)** | `L:` | `L1:` | Marcador de posi√ß√£o para saltos. |
| **Entrada (Read)** | `read x` | `read idade` | Leitura de dados do usu√°rio. |
| **Sa√≠da (Print)** | `print x` | `print t1` | Escrita de dados na tela. |


üõ†Ô∏è Gerador de C√≥digo Implementado
Estrutura do Gerador

Arquivo: src/main/java/MiniPascalCodeGenerator.java

O gerador utiliza o Visitor Pattern para percorrer a AST. Para cada n√≥ da √°rvore, ele emite uma ou mais instru√ß√µes TAC.

Tempor√°rias: Geradas automaticamente como t0, t1, t2... atrav√©s do m√©todo newTemp().
R√≥tulos: Gerados como L0, L1, L2... atrav√©s do m√©todo newLabel(), essenciais para IF, WHILE e FOR.

Codigo do Gerador

import java.util.ArrayList;
import java.util.List;

/**
 * Esta classe percorre a √°rvore gerada pelo ANTLR e traduz os comandos para
 * C√≥digo de Tr√™s Endere√ßos (C3E). Cada m√©todo 'visit' lida com uma regra da gram√°tica.
 */
public class MiniPascalCodeGenerator extends miniPascalBaseVisitor<String> {

    private final List<Instruction> instructions = new ArrayList<>();
    
    private int tempCount = 0;
    private int labelCount = 0;

    private String newTemp() {
        return "t" + (tempCount++);
    }

    private String newLabel() {
        return "L" + (labelCount++);
    }

    public List<Instruction> getInstructions() {
        return instructions;
    }

    public void printInstructions() {
        System.out.println("\n=== C√ìDIGO INTERMEDI√ÅRIO GERADO (C3E) ===");
        for (Instruction instr : instructions) {
            System.out.println(instr);
        }
    }

    // === ATRIBUI√á√ÉO: x := express√£o ===

    @Override
    public String visitAssignmentStatement(miniPascalParser.AssignmentStatementContext ctx) {
        String variable = ctx.identifier().getText(); // Identifica o destino (lado esquerdo)
        String value = visit(ctx.expression());       // Resolve a express√£o (lado direito)
        
        instructions.add(new Instruction(variable, value, null, null));
        return variable;
    }

    // === EXPRESS√ïES RELACIONAIS (ex: x > 15) ===

    @Override
    public String visitExpression(miniPascalParser.ExpressionContext ctx) {

        if (ctx.relationalOperator() != null && !ctx.relationalOperator().isEmpty()) {
            String left = visit(ctx.simpleExpression(0));
            String op = ctx.relationalOperator(0).getText(); 
            String right = visit(ctx.simpleExpression(1));
            
            String target = newTemp(); // Cria tempor√°rio para armazenar o resultado booleano
            instructions.add(new Instruction(target, left, op, right)); // Ex: t2 := x > 15
            return target;
        }

        return visit(ctx.simpleExpression(0));
    }

    // === EXPRESS√ïES ARITM√âTICAS (Soma, Subtra√ß√£o, OR) ===

    @Override
    public String visitSimpleExpression(miniPascalParser.SimpleExpressionContext ctx) {
        String lastResult = visit(ctx.term(0)); // Pega o primeiro termo
        
        for (int i = 0; i < ctx.additiveOperator().size(); i++) {
            String op = ctx.additiveOperator(i).getText();
            String nextTerm = visit(ctx.term(i + 1));
            String target = newTemp();
            
            instructions.add(new Instruction(target, lastResult, op, nextTerm));
            lastResult = target;
        }
        return lastResult;
    }

    // === OPERA√á√ïES DE ALTA PRECED√äNCIA (Multiplica√ß√£o, Divis√£o, AND) ===

    @Override
    public String visitTerm(miniPascalParser.TermContext ctx) {
        String lastResult = visit(ctx.factor(0));
        
        for (int i = 0; i < ctx.multiplicativeOperator().size(); i++) {
            String op = ctx.multiplicativeOperator(i).getText();
            String nextFactor = visit(ctx.factor(i + 1));
            String target = newTemp();
            
            instructions.add(new Instruction(target, lastResult, op, nextFactor));
            lastResult = target;
        }
        return lastResult;
    }

    // === FATORES (Base da express√£o: n√∫meros, vari√°veis, express√µes entre par√™nteses) ===

    @Override
    public String visitFactor(miniPascalParser.FactorContext ctx) {

        if (ctx.identifier() != null) {
            return ctx.identifier().getText();
        }
        
        if (ctx.unsignedNumber() != null) {
            return ctx.unsignedNumber().getText();
        }
        
        if (ctx.stringLiteral() != null) {
            return ctx.stringLiteral().getText();
        }
        
        if (ctx.boolLiteral() != null) {
            return ctx.boolLiteral().getText();
        }
        
        if (ctx.expression() != null) {
            return visit(ctx.expression());
        }
        
        if (ctx.NOT() != null) {
            String operand = visit(ctx.getChild(1)); // Pega o factor ap√≥s NOT
            String target = newTemp();
            instructions.add(new Instruction(target, operand, "NOT", null));
            return target;
        }
        
        if (ctx.PLUS() != null) {
            return visit(ctx.getChild(1)); // Pega o factor ap√≥s +
        }
        
        if (ctx.MINUS() != null) {
            String operand = visit(ctx.getChild(1)); // Pega o factor ap√≥s -
            String target = newTemp();
            instructions.add(new Instruction(target, "0", "-", operand));
            return target;
        }

        return ctx.getText();
    }

    // === CONTROLE DE FLUXO: IF THEN ELSE ===

    @Override
    public String visitIfStatement(miniPascalParser.IfStatementContext ctx) {
        String condition = visit(ctx.expression()); // Avalia a condi√ß√£o booleana
        String labelElse = newLabel(); // R√≥tulo para onde pular se for falso
        String labelEnd = newLabel();  // R√≥tulo para o fim do IF

        instructions.add(new Instruction(labelElse, condition, "IF_FALSE", null));
        
        visit(ctx.statement(0)); // Executa o bloco do THEN
        instructions.add(new Instruction(labelEnd, null, "GOTO", null)); // Pula o ELSE
        
        instructions.add(new Instruction(labelElse, null, "LABEL", null)); // Marca o in√≠cio do ELSE
        if (ctx.statement().size() > 1) {
            visit(ctx.statement(1)); // Executa o bloco ELSE se existir
        }
        instructions.add(new Instruction(labelEnd, null, "LABEL", null)); // Marca o fim de tudo
        
        return null;
    }

    // === LA√áO DE REPETI√á√ÉO: WHILE DO ===

    @Override
    public String visitWhileStatement(miniPascalParser.WhileStatementContext ctx) {
        String labelStart = newLabel(); // R√≥tulo para voltar ao teste da condi√ß√£o
        String labelEnd = newLabel();   // R√≥tulo para sair do la√ßo

        instructions.add(new Instruction(labelStart, null, "LABEL", null)); // In√≠cio do loop
        String condition = visit(ctx.expression()); // Testa a condi√ß√£o
        
        instructions.add(new Instruction(labelEnd, condition, "IF_FALSE", null)); // Sai se for falso
        visit(ctx.statement()); // Executa o corpo do loop
        
        instructions.add(new Instruction(labelStart, null, "GOTO", null)); // Volta ao topo
        instructions.add(new Instruction(labelEnd, null, "LABEL", null)); // Alvo da sa√≠da
        
        return null;
    }

    // === LA√áO DE REPETI√á√ÉO: FOR TO/DOWNTO ===

    @Override
    public String visitForStatement(miniPascalParser.ForStatementContext ctx) {
        String var = ctx.identifier().getText();
        String start = visit(ctx.expression(0));
        String end = visit(ctx.expression(1));
        
        instructions.add(new Instruction(var, start, null, null));
        
        String labelStart = newLabel();
        String labelEnd = newLabel();
        
        instructions.add(new Instruction(labelStart, null, "LABEL", null));
        
        String condition = newTemp();
        String op = ctx.TO() != null ? ">" : "<";
        instructions.add(new Instruction(condition, var, op, end));
        instructions.add(new Instruction(labelEnd, condition, "IF_TRUE", null));
        
        visit(ctx.statement());
        
        String temp = newTemp();
        String incOp = ctx.TO() != null ? "+" : "-";
        instructions.add(new Instruction(temp, var, incOp, "1"));
        instructions.add(new Instruction(var, temp, null, null));
        
        instructions.add(new Instruction(labelStart, null, "GOTO", null));
        
        instructions.add(new Instruction(labelEnd, null, "LABEL", null));
        
        return null;
    }

    // === ENTRADA E SA√çDA (READ e WRITE/PRINT) ===

    @Override
    public String visitIoStatement(miniPascalParser.IoStatementContext ctx) {
        if (ctx.READ() != null) {
            for (miniPascalParser.IdentifierContext idCtx : ctx.identifier()) {
                instructions.add(new Instruction("READ", idCtx.getText(), null, null));
            }
        } else if (ctx.WRITE() != null || ctx.PRINT() != null) {
            for (miniPascalParser.ExpressionContext exprCtx : ctx.expression()) {
                String val = visit(exprCtx); 
                instructions.add(new Instruction("PRINT", val, null, null));
            }
        }
        return null;
    }

    public void saveToFile(String filename) {
        String outputDir = "test-reports/tac-output/";
        java.io.File dir = new java.io.File(outputDir);
        if (!dir.exists()) {
            dir.mkdirs(); // Cria pasta se n√£o existir
        }
        
        String fullPath = outputDir + filename;
        
        try (java.io.FileWriter writer = new java.io.FileWriter(fullPath, false)) {
            writer.write("=== C√ìDIGO INTERMEDI√ÅRIO GERADO (C3E) ===\n");
            writer.write("Data/Hora: " + java.time.LocalDateTime.now() + "\n");
            writer.write("Total de Instru√ß√µes: " + instructions.size() + "\n");
            writer.write("===========================================\n\n");
            
            for (Instruction instr : instructions) {
                writer.write(instr.toString() + "\n");
            }
            
            System.out.println(" C√≥digo salvo em: " + fullPath);
        } catch (java.io.IOException e) {
            System.err.println(" Erro ao salvar arquivo: " + e.getMessage());
        }
    }
}


üöÄ Como Executar

Passo 1: Compilar o Projeto
mvn clean compile

Passo 2: Executar o Menu Interativo
mvn exec:java
ou
java -cp target/classes Main

Passo 3: Gerar C√≥digo Intermedi√°rio (Demo)
No menu principal, selecione a Op√ß√£o 8:

ESCOLHA UMA OP√á√ÉO:
...
7 - Demo Sem√¢ntica (tabela de s√≠mbolos + escopos)
8 - Entrega 4: Gera√ß√£o de C√≥digo Intermedi√°rio (C3E)
9 - Ver localiza√ß√£o dos relat√≥rios de testes
0 - Sair

Op√ß√£o: 8

Sa√≠da Esperada (Exemplo):

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   DEMO GERA√á√ÉO DE C√ìDIGO INTERMEDI√ÅRIO (C3E)           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

EXECUTANDO TESTE 1:
C√≥digo de entrada:
program Exemplo;
var x, y: integer;
begin
  x := 10 + 5 * 2;
  print(x);
end.

C√≥digo Intermedi√°rio Gerado:
t0 = 5 * 2
t1 = 10 + t0
x = t1
print x

‚úÖ Gera√ß√£o conclu√≠da com sucesso!
üìÑ Arquivos salvos em: test-reports/tac-output/

üìÇ Relat√≥rios Gerados
Localiza√ß√£o dos Arquivos

test-reports/
‚îú‚îÄ‚îÄ tac-output/                     # C√≥digo TAC gerado
    ‚îú‚îÄ‚îÄ teste1_output.tac
    ‚îú‚îÄ‚îÄ teste2_output.tac
    ‚îî‚îÄ‚îÄ teste3_output.tac

Exemplo de Arquivo TAC
Arquivo: test-reports/tac-output/teste2_output.tac

x := 5
y := 10
t0 := x + 5
t1 := y - 2
t2 := t0 * t1
resultado := t2
L0:
t3 := resultado < 100
if t3 FALSE  goto L1
t4 := resultado + 1
resultado := t4
goto L0
L1:

üß™ Testes Implementados

| Teste | Descri√ß√£o | Status |
| :--- | :--- | :--- |
| `testAtribuicao` | Valida TAC para x := 10. | ‚úÖ Passou |
| `testExpressoes` | Valida preced√™ncia em a + b * c. | ‚úÖ Passou |
| `testIfElse` | Valida saltos if e goto em condicionais. | ‚úÖ Passou |
| `testWhile` | Valida estrutura de repeti√ß√£o com r√≥tulos. | ‚úÖ Passou |
| `testFor` | Valida la√ßos to e downto. | ‚úÖ Passou |
| `testIO` | Valida instru√ß√µes read e print. | ‚úÖ Passou |


üìä Resumo da Entrega

| Item | Status |
| :--- | :--- |
| Gerador TAC Implementado | ‚úÖ Completo |
| Suporte a Estruturas de Controle | ‚úÖ IF, WHILE, FOR |
| Gerenciamento de Tempor√°rias | ‚úÖ Implementado |
| Gerenciador de R√≥tulos | ‚úÖ Implementado |
| Relat√≥rios em Arquivo | ‚úÖ Gerados em .tac |
| Documenta√ß√£o | ‚úÖ Completa |


üìö Refer√™ncias
Dragon Book: Compilers: Principles, Techniques, and Tools (Aho, Sethi, Ullman) - Cap√≠tulo 6 (Intermediate-Code Generation)
Engineering a Compiler: Keith Cooper & Linda Torczon - Cap√≠tulo 5 (Intermediate Representations)
Modern Compiler Implementation in Java: Andrew W. Appel - Cap√≠tulo 7 (Translation to Intermediate Code)


## üìù Hist√≥rico de Vers√µes

| Vers√£o | Data | Descri√ß√£o | Autor |
|--------|------|-----------|-------|
| 1.0 | 04/02/2026 | Vers√£o inicial da entrega 4 | Equipe Mini-Pascal |


üë• Autores
Enaldo Dantas  - jose.santos259@academico.ifs.edu.br
Agnaldo Neto   - jose.neto044@academico.ifs.edu.br
Vitorio Mota   - vitorio.mota085@academico.ifs.edu.br
Lucas Oliveira - lucas.oliveira031@academico.ifs.edu.br


üìû ContatoPara d√∫vidas sobre esta entrega:
Email: jeds@outlook.com.br
GitHub: https://github.com/jeds2025

Entrega 4 conclu√≠da com sucesso! ‚úÖ
Desenvolvido para IFS Campus Itabaiana - 2025.2
Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES



