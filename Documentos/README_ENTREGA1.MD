# üìò Entrega 1: Gram√°tica da Linguagem (BNF/EBNF)

**Compilador Mini-Pascal - IFS Campus Itabaiana 2025.2**

*Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES*

---

## üìÖ Informa√ß√µes da Entrega

| Item | Descri√ß√£o |
|------|-----------|
| **N√∫mero da Entrega** | 1 |
| **Data de Entrega** | 14/01/2026 |
| **Objetivo** | Definir formalmente a Mini-Linguagem utilizando BNF/EBNF |
| **Status** | ‚úÖ Conclu√≠do |
| **Respons√°veis** | Enaldo Dantas, Agnaldo Neto, Vitorio Mota, Lucas Oliveira |

---

## üìã √çndice

- [Objetivo](#objetivo)
- [Conceito](#conceito)
- [Artefatos Entregues](#artefatos-entregues)
- [Gram√°tica BNF/EBNF Completa](#gram√°tica-bnfebnf-completa)
- [Comandos Suportados](#comandos-suportados)
- [Estrutura da Gram√°tica ANTLR](#estrutura-da-gram√°tica-antlr)
- [Exemplos de C√≥digo V√°lido](#exemplos-de-c√≥digo-v√°lido)
- [Exemplos de C√≥digo Inv√°lido](#exemplos-de-c√≥digo-inv√°lido)
- [Preced√™ncia de Operadores](#preced√™ncia-de-operadores)
- [Como Gerar o Parser/Lexer](#como-gerar-o-parserlexer)
- [Valida√ß√£o e Testes](#valida√ß√£o-e-testes)
- [Checklist de Entrega](#checklist-de-entrega)

---

## üéØ Objetivo

Definir as **"regras do jogo"** da linguagem Mini-Pascal atrav√©s de uma gram√°tica formal que especifica:

- ‚úÖ **Estrutura de um programa v√°lido**: Como organizar declara√ß√µes e comandos
- ‚úÖ **Declara√ß√£o de vari√°veis e tipos**: Suporte a `integer`, `real`, `string`, `boolean`
- ‚úÖ **Comandos de controle**: Atribui√ß√£o, entrada/sa√≠da, condicionais e la√ßos
- ‚úÖ **Express√µes**: Aritm√©ticas, relacionais e l√≥gicas com preced√™ncia definida
- ‚úÖ **Regras l√©xicas**: Identificadores, n√∫meros, strings, palavras-reservadas

---

## üí° Conceito

A gram√°tica √© a **especifica√ß√£o formal** da linguagem Mini-Pascal. Ela define:

### 1. **Estrutura do Programa**
Todo programa Mini-Pascal segue a estrutura:

program ;
[var <declara√ß√µes>]
begin

end.


### 2. **Tipos de Dados Suportados**
- `integer` - N√∫meros inteiros
- `real` - N√∫meros reais (ponto flutuante)
- `string` - Cadeias de caracteres
- `boolean` - Valores l√≥gicos (`true`, `false`)

### 3. **Comandos Suportados**
- **Atribui√ß√£o**: `x := express√£o;`
- **Entrada**: `read(var1, var2, ...);`
- **Sa√≠da**: `print(expr1, expr2, ...);`
- **Condicional**: `if express√£o then comando [else comando]`
- **La√ßo While**: `while express√£o do comando`
- **La√ßo For**: `for var := expr to/downto expr do comando`

### 4. **Express√µes com Preced√™ncia**
- Operadores relacionais: `=`, `<>`, `<`, `<=`, `>`, `>=`
- Operadores aditivos: `+`, `-`, `or`
- Operadores multiplicativos: `*`, `/`, `and`
- Operadores un√°rios: `not`, `+` (un√°rio), `-` (un√°rio)

---

## üì¶ Artefatos Entregues

### Arquivos Principais

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| `miniPascal.g4` | `src/main/antlr4/` | Gram√°tica ANTLR completa do Mini-Pascal |
| `README_ENTREGA1.md` | Raiz do projeto | Este documento de entrega |

### Arquivos Gerados (ap√≥s `mvn generate-sources`)

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| `miniPascalLexer.java` | `target/generated-sources/antlr4/` | Analisador l√©xico gerado pelo ANTLR |
| `miniPascalParser.java` | `target/generated-sources/antlr4/` | Analisador sint√°tico gerado pelo ANTLR |
| `miniPascalBaseVisitor.java` | `target/generated-sources/antlr4/` | Classe base para visitor pattern |
| `miniPascalVisitor.java` | `target/generated-sources/antlr4/` | Interface do visitor pattern |
| `miniPascal.tokens` | `target/generated-sources/antlr4/` | Arquivo de tokens gerados |
| `miniPascalLexer.tokens` | `target/generated-sources/antlr4/` | Tokens do lexer |

---

## üìù Gram√°tica BNF/EBNF Completa

### Nota√ß√£o Utilizada

- `"texto"` - Terminal (palavra-reservada ou s√≠mbolo)
- `regra` - N√£o-terminal
- `|` - Alternativa (ou)
- `[ ... ]` - Opcional (zero ou uma vez)
- `{ ... }` - Repeti√ß√£o (zero ou mais vezes)
- `( ... )` - Agrupamento

---

1. Programa e Bloco
```ebnf
program =
    "program", identifier, ";", block, "." ;

block =
    [ variable-declaration-part ], compound-statement ;

variable-declaration-part =
    "var", variable-declaration, { ";", variable-declaration }, ";" ;

variable-declaration =
    identifier-list, ":", type ;

identifier-list =
    identifier, { ",", identifier } ;

type =
    "integer"
  | "real"
  | "string"
  | "boolean" ;

identifier =
    letter, { letter | digit | "_" } ;




Descri√ß√£o:

Todo programa inicia com a palavra-reservada program seguida de um identificador
Declara√ß√µes de vari√°veis s√£o opcionais (indicado por [ ... ])
M√∫ltiplas vari√°veis podem ser declaradas em uma √∫nica linha separadas por v√≠rgula
O bloco principal (compound-statement) √© obrigat√≥rio
O programa termina com ponto final (.)

Exemplo:

program MeuPrograma;
var
    x, y: integer;
    z: real;
begin
    x := 10;
end.

2. Comandos

compound-statement =
    "begin", statement-list, "end" ;

statement-list =
    statement, { ";", statement } ;

statement =
    simple-statement
  | structured-statement
  | (* vazio *) ;

simple-statement =
    assignment-statement
  | io-statement ;

assignment-statement =
    identifier, ":=", expression ;

io-statement =
    "read", "(", identifier, { ",", identifier }, ")"
  | "print", "(", expression, { ",", expression }, ")" ;

structured-statement =
    if-statement
  | while-statement
  | for-statement
  | compound-statement ;

if-statement =
    "if", expression, "then", statement, [ "else", statement ] ;

while-statement =
    "while", expression, "do", statement ;

for-statement =
    "for", identifier, ":=", expression,
    ( "to" | "downto" ), expression,
    "do", statement ;

Descri√ß√£o:
Comandos Simples: Atribui√ß√£o (x := 10) e I/O (read, print)
Comandos Estruturados: Condicionais (if-then-else), la√ßos (while, for) e blocos compostos
Comandos Vazios: Permitidos (ponto e v√≠rgula duplo ;;)

Exemplos:
Atribui√ß√£o:
x := 10 + y * 2;

Entrada/Sa√≠da:
read(x, y);
print('Resultado:', x + y);

Condicional:
if x > 0 then
    y := 1
else
    y := 0;

La√ßo While:
while i < 10 do
    i := i + 1;

La√ßo For:
for i := 1 to 5 do
    print(i);

for i := 5 downto 1 do
    print(i);

3. Express√µes (com Preced√™ncia)

expression =
    simple-expression, [ relational-operator, simple-expression ] ;

relational-operator =
    "="  | "<>" | "<" | "<=" | ">" | ">=" ;

simple-expression =
    term, { additive-operator, term } ;

additive-operator =
    "+" | "-" | "or" ;

term =
    factor, { multiplicative-operator, factor } ;

multiplicative-operator =
    "*" | "/" | "and" ;

factor =
    identifier
  | unsigned-number
  | string-literal
  | boolean-literal
  | "(", expression, ")"
  | "not", factor
  | "+", factor
  | "-", factor ;


Descri√ß√£o:
A gram√°tica define a preced√™ncia de operadores atrav√©s da hierarquia de regras:
Express√µes relacionais (menor preced√™ncia): =, <>, <, <=, >, >=
Express√µes aditivas: +, -, or
Termos multiplicativos: *, /, and
Fatores (maior preced√™ncia): not, + (un√°rio), - (un√°rio), par√™nteses

Exemplos de Avalia√ß√£o:
z := 10 + 5 * 2;     // Equivale a: z := 10 + (5 * 2) = 20
z := (10 + 5) * 2;   // Equivale a: z := 15 * 2 = 30
z := not x and y;    // Equivale a: z := (not x) and y


4. L√©xico (Tokens B√°sicos)

unsigned-number =
    integer
  | real ;

integer =
    digit, { digit } ;

real =
    digit, { digit }, ".", digit, { digit } ;

string-literal =
    "'", { character - "'" | "''" }, "'" ;

boolean-literal =
    "true" | "false" ;

letter =
    "A" | "B" | ... | "Z"
  | "a" | "b" | ... | "z" ;

digit  =
    "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;


Descri√ß√£o:
N√∫meros Inteiros: Sequ√™ncia de d√≠gitos (123, 0, 999)
N√∫meros Reais: D√≠gitos, ponto, d√≠gitos (123.45, 0.5, 3.14159)
Strings: Delimitadas por aspas simples ('texto', 'Hello World')
Aspas simples dentro de strings s√£o escapadas duplicando: 'it''s' ‚Üí it's
Booleanos: Apenas true ou false
Identificadores: Iniciam com letra, podem conter letras, d√≠gitos e underscore (_)
V√°lidos: x, contador, valor_total, Nota1
Inv√°lidos: 1x (inicia com d√≠gito), x-y (h√≠fen n√£o permitido)

üõ†Ô∏è Comandos Suportados

ComandoSintaxeDescri√ß√£oExemploAtribui√ß√£ovar := expr;Atribui valor a uma vari√°velx := 10 + y * 2;Entradaread(var1, var2, ...);L√™ valores do usu√°rioread(x, y);Sa√≠daprint(expr1, expr2, ...);Imprime valores na telaprint('Resultado:', x);Condicionalif expr then cmd [else cmd]Executa comando condicionalmenteif x > 0 then y := 1 else y := 0;La√ßo Whilewhile expr do cmdRepete enquanto condi√ß√£o for verdadeirawhile i < 10 do i := i + 1;La√ßo For (crescente)for var := expr to expr do cmdLa√ßo com contador crescentefor i := 1 to 5 do print(i);La√ßo For (decrescente)for var := expr downto expr do cmdLa√ßo com contador decrescentefor i := 5 downto 1 do print(i);












