# ğŸ“˜ Entrega 1: GramÃ¡tica da Linguagem (BNF/EBNF)

**Compilador Mini-Pascal - IFS Campus Itabaiana 2025.2**

*Disciplina: LINGUAGENS FORMAIS, AUTÃ”MATOS E COMPILADORES*

---

## ğŸ“… InformaÃ§Ãµes da Entrega

| Item | DescriÃ§Ã£o |
|------|-----------|
| **NÃºmero da Entrega** | 1 |
| **Data de Entrega** | 14/01/2026 |
| **Objetivo** | Definir formalmente a Mini-Linguagem utilizando BNF/EBNF |
| **Status** | âœ… ConcluÃ­do |
| **ResponsÃ¡veis** | Enaldo Dantas, Agnaldo Neto, Vitorio Mota, Lucas Oliveira |

---

## ğŸ“‹ Ãndice

- [Objetivo](#objetivo)
- [Conceito](#conceito)
- [Artefatos Entregues](#artefatos-entregues)
- [GramÃ¡tica BNF/EBNF Completa](#gramÃ¡tica-bnfebnf-completa)
- [Comandos Suportados](#comandos-suportados)
- [Estrutura da GramÃ¡tica ANTLR](#estrutura-da-gramÃ¡tica-antlr)
- [Exemplos de CÃ³digo VÃ¡lido](#exemplos-de-cÃ³digo-vÃ¡lido)
- [Exemplos de CÃ³digo InvÃ¡lido](#exemplos-de-cÃ³digo-invÃ¡lido)
- [PrecedÃªncia de Operadores](#precedÃªncia-de-operadores)
- [Como Gerar o Parser/Lexer](#como-gerar-o-parserlexer)
- [ValidaÃ§Ã£o e Testes](#validaÃ§Ã£o-e-testes)
- [Checklist de Entrega](#checklist-de-entrega)

---

## ğŸ¯ Objetivo

Definir as **"regras do jogo"** da linguagem Mini-Pascal atravÃ©s de uma gramÃ¡tica formal que especifica:

- âœ… **Estrutura de um programa vÃ¡lido**: Como organizar declaraÃ§Ãµes e comandos
- âœ… **DeclaraÃ§Ã£o de variÃ¡veis e tipos**: Suporte a `integer`, `real`, `string`, `boolean`
- âœ… **Comandos de controle**: AtribuiÃ§Ã£o, entrada/saÃ­da, condicionais e laÃ§os
- âœ… **ExpressÃµes**: AritmÃ©ticas, relacionais e lÃ³gicas com precedÃªncia definida
- âœ… **Regras lÃ©xicas**: Identificadores, nÃºmeros, strings, palavras-reservadas

---

## ğŸ’¡ Conceito

A gramÃ¡tica Ã© a **especificaÃ§Ã£o formal** da linguagem Mini-Pascal. Ela define:

### 1. **Estrutura do Programa**
Todo programa Mini-Pascal segue a estrutura:

program ;
[var <declaraÃ§Ãµes>]
begin

end.


### 2. **Tipos de Dados Suportados**
- `integer` - NÃºmeros inteiros
- `real` - NÃºmeros reais (ponto flutuante)
- `string` - Cadeias de caracteres
- `boolean` - Valores lÃ³gicos (`true`, `false`)

### 3. **Comandos Suportados**
- **AtribuiÃ§Ã£o**: `x := expressÃ£o;`
- **Entrada**: `read(var1, var2, ...);`
- **SaÃ­da**: `print(expr1, expr2, ...);`
- **Condicional**: `if expressÃ£o then comando [else comando]`
- **LaÃ§o While**: `while expressÃ£o do comando`
- **LaÃ§o For**: `for var := expr to/downto expr do comando`

### 4. **ExpressÃµes com PrecedÃªncia**
- Operadores relacionais: `=`, `<>`, `<`, `<=`, `>`, `>=`
- Operadores aditivos: `+`, `-`, `or`
- Operadores multiplicativos: `*`, `/`, `and`
- Operadores unÃ¡rios: `not`, `+` (unÃ¡rio), `-` (unÃ¡rio)

---

## ğŸ“¦ Artefatos Entregues

### Arquivos Principais

| Arquivo | LocalizaÃ§Ã£o | DescriÃ§Ã£o |
|---------|-------------|-----------|
| `miniPascal.g4` | `src/main/antlr4/` | GramÃ¡tica ANTLR completa do Mini-Pascal |
| `README_ENTREGA1.md` | Raiz do projeto | Este documento de entrega |

### Arquivos Gerados (apÃ³s `mvn generate-sources`)

| Arquivo | LocalizaÃ§Ã£o | DescriÃ§Ã£o |
|---------|-------------|-----------|
| `miniPascalLexer.java` | `target/generated-sources/antlr4/` | Analisador lÃ©xico gerado pelo ANTLR |
| `miniPascalParser.java` | `target/generated-sources/antlr4/` | Analisador sintÃ¡tico gerado pelo ANTLR |
| `miniPascalBaseVisitor.java` | `target/generated-sources/antlr4/` | Classe base para visitor pattern |
| `miniPascalVisitor.java` | `target/generated-sources/antlr4/` | Interface do visitor pattern |
| `miniPascal.tokens` | `target/generated-sources/antlr4/` | Arquivo de tokens gerados |
| `miniPascalLexer.tokens` | `target/generated-sources/antlr4/` | Tokens do lexer |

---

## ğŸ“ GramÃ¡tica BNF/EBNF Completa

### NotaÃ§Ã£o Utilizada

- `"texto"` - Terminal (palavra-reservada ou sÃ­mbolo)
- `regra` - NÃ£o-terminal
- `|` - Alternativa (ou)
- `[ ... ]` - Opcional (zero ou uma vez)
- `{ ... }` - RepetiÃ§Ã£o (zero ou mais vezes)
- `( ... )` - Agrupamento

---

1. Programa e Bloco
```ebnf
program =
    "program", identifier, ";", block, "." ;

block =
    [ variable-declaration-part ], compound-statement ;

variable-declaration-part =
    "var", variable-declaration, { ";", variable-declaration }, ";" ;

variable-declaration =
    identifier-list, ":", type ;

identifier-list =
    identifier, { ",", identifier } ;

type =
    "integer"
  | "real"
  | "string"
  | "boolean" ;

identifier =
    letter, { letter | digit | "_" } ;




DescriÃ§Ã£o:

Todo programa inicia com a palavra-reservada program seguida de um identificador
DeclaraÃ§Ãµes de variÃ¡veis sÃ£o opcionais (indicado por [ ... ])
MÃºltiplas variÃ¡veis podem ser declaradas em uma Ãºnica linha separadas por vÃ­rgula
O bloco principal (compound-statement) Ã© obrigatÃ³rio
O programa termina com ponto final (.)

Exemplo:

program MeuPrograma;
var
    x, y: integer;
    z: real;
begin
    x := 10;
end.

2. Comandos

compound-statement =
    "begin", statement-list, "end" ;

statement-list =
    statement, { ";", statement } ;

statement =
    simple-statement
  | structured-statement
  | (* vazio *) ;

simple-statement =
    assignment-statement
  | io-statement ;

assignment-statement =
    identifier, ":=", expression ;

io-statement =
    "read", "(", identifier, { ",", identifier }, ")"
  | "print", "(", expression, { ",", expression }, ")" ;

structured-statement =
    if-statement
  | while-statement
  | for-statement
  | compound-statement ;

if-statement =
    "if", expression, "then", statement, [ "else", statement ] ;

while-statement =
    "while", expression, "do", statement ;

for-statement =
    "for", identifier, ":=", expression,
    ( "to" | "downto" ), expression,
    "do", statement ;

DescriÃ§Ã£o:
Comandos Simples: AtribuiÃ§Ã£o (x := 10) e I/O (read, print)
Comandos Estruturados: Condicionais (if-then-else), laÃ§os (while, for) e blocos compostos
Comandos Vazios: Permitidos (ponto e vÃ­rgula duplo ;;)

Exemplos:
AtribuiÃ§Ã£o:
x := 10 + y * 2;

Entrada/SaÃ­da:
read(x, y);
print('Resultado:', x + y);

Condicional:
if x > 0 then
    y := 1
else
    y := 0;

LaÃ§o While:
while i < 10 do
    i := i + 1;

LaÃ§o For:
for i := 1 to 5 do
    print(i);

for i := 5 downto 1 do
    print(i);

3. ExpressÃµes (com PrecedÃªncia)

expression =
    simple-expression, [ relational-operator, simple-expression ] ;

relational-operator =
    "="  | "<>" | "<" | "<=" | ">" | ">=" ;

simple-expression =
    term, { additive-operator, term } ;

additive-operator =
    "+" | "-" | "or" ;

term =
    factor, { multiplicative-operator, factor } ;

multiplicative-operator =
    "*" | "/" | "and" ;

factor =
    identifier
  | unsigned-number
  | string-literal
  | boolean-literal
  | "(", expression, ")"
  | "not", factor
  | "+", factor
  | "-", factor ;


DescriÃ§Ã£o:
A gramÃ¡tica define a precedÃªncia de operadores atravÃ©s da hierarquia de regras:
ExpressÃµes relacionais (menor precedÃªncia): =, <>, <, <=, >, >=
ExpressÃµes aditivas: +, -, or
Termos multiplicativos: *, /, and
Fatores (maior precedÃªncia): not, + (unÃ¡rio), - (unÃ¡rio), parÃªnteses

Exemplos de AvaliaÃ§Ã£o:
z := 10 + 5 * 2;     // Equivale a: z := 10 + (5 * 2) = 20
z := (10 + 5) * 2;   // Equivale a: z := 15 * 2 = 30
z := not x and y;    // Equivale a: z := (not x) and y


4. LÃ©xico (Tokens BÃ¡sicos)

unsigned-number =
    integer
  | real ;

integer =
    digit, { digit } ;

real =
    digit, { digit }, ".", digit, { digit } ;

string-literal =
    "'", { character - "'" | "''" }, "'" ;

boolean-literal =
    "true" | "false" ;

letter =
    "A" | "B" | ... | "Z"
  | "a" | "b" | ... | "z" ;

digit  =
    "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;


DescriÃ§Ã£o:
NÃºmeros Inteiros: SequÃªncia de dÃ­gitos (123, 0, 999)
NÃºmeros Reais: DÃ­gitos, ponto, dÃ­gitos (123.45, 0.5, 3.14159)
Strings: Delimitadas por aspas simples ('texto', 'Hello World')
Aspas simples dentro de strings sÃ£o escapadas duplicando: 'it''s' â†’ it's
Booleanos: Apenas true ou false
Identificadores: Iniciam com letra, podem conter letras, dÃ­gitos e underscore (_)
VÃ¡lidos: x, contador, valor_total, Nota1
InvÃ¡lidos: 1x (inicia com dÃ­gito), x-y (hÃ­fen nÃ£o permitido)

ğŸ› ï¸ Comandos Suportados
## ğŸ› ï¸ Comandos Suportados

| Comando                | Sintaxe                              | DescriÃ§Ã£o                               | Exemplo                             |
|------------------------|--------------------------------------|-----------------------------------------|-------------------------------------|
| AtribuiÃ§Ã£o             | `var := expr;`                       | Atribui valor a uma variÃ¡vel            | `x := 10 + y * 2;`                  |
| Entrada                | `read(var1, var2, ...);`             | LÃª valores do usuÃ¡rio                   | `read(x, y);`                       |
| SaÃ­da                  | `print(expr1, expr2, ...);`          | Imprime valores na tela                 | `print('Resultado:', x);`           |
| Condicional            | `if expr then cmd [else cmd]`        | Executa comando condicionalmente        | `if x > 0 then y := 1 else y := 0;` |
| LaÃ§o While             | `while expr do cmd`                  | Repete enquanto condiÃ§Ã£o for verdadeira | `while i < 10 do i := i + 1;`       |
| LaÃ§o For (crescente)   | `for var := expr to expr do cmd`     | LaÃ§o com contador crescente             | `for i := 1 to 5 do print(i);`      |
| LaÃ§o For (decrescente) | `for var := expr downto expr do cmd` | LaÃ§o com contador decrescente           | `for i := 5 downto 1 do print(i);`  |


ğŸ”§ Estrutura da GramÃ¡tica ANTLR
LocalizaÃ§Ã£o do Arquivosrc/main/antlr4/miniPascal.g4
Estrutura Geral do Arquivo
O arquivo miniPascal.g4 estÃ¡ organizado em duas seÃ§Ãµes principais:
Regras do Parser (sintÃ¡ticas) - Definem a estrutura da linguagem
Regras do Lexer (lÃ©xicas) - Definem os tokens

Principais Regras do Parser

grammar miniPascal;

// ===== REGRAS DO PARSER (SintÃ¡ticas) =====

program
    : PROGRAM identifier SEMICOLON 
      variableDeclarationPart? 
      compoundStatement DOT EOF
    ;

variableDeclarationPart
    : VAR variableDeclaration (SEMICOLON variableDeclaration)* SEMICOLON?
    ;

variableDeclaration
    : identifierList COLON type
    ;

identifierList
    : identifier (COMMA identifier)*
    ;

type
    : INTEGER_TYPE
    | REAL_TYPE
    | STRING_TYPE
    | BOOLEAN_TYPE
    ;

compoundStatement
    : BEGIN statement (SEMICOLON statement)* END
    ;

statement
    : assignmentStatement
    | ifStatement
    | whileStatement
    | forStatement
    | ioStatement
    | compoundStatement
    | // comando vazio
    ;

assignmentStatement
    : identifier ASSIGN expression
    ;

ifStatement
    : IF expression THEN statement (ELSE statement)?
    ;

whileStatement
    : WHILE expression DO statement
    ;

forStatement
    : FOR identifier ASSIGN expression (TO | DOWNTO) expression DO statement
    ;

ioStatement
    : READ LPAREN identifierList RPAREN
    | PRINT LPAREN expressionList RPAREN
    ;

expressionList
    : expression (COMMA expression)*
    ;

expression
    : simpleExpression (relationalOperator simpleExpression)?
    ;

relationalOperator
    : EQUAL
    | NOT_EQUAL
    | LESS_THAN
    | LESS_EQUAL
    | GREATER_THAN
    | GREATER_EQUAL
    ;

simpleExpression
    : term (additiveOperator term)*
    ;

additiveOperator
    : PLUS
    | MINUS
    | OR
    ;

term
    : factor (multiplicativeOperator factor)*
    ;

multiplicativeOperator
    : MULTIPLY
    | DIVIDE
    | AND
    ;

factor
    : identifier
    | unsignedNumber
    | stringLiteral
    | boolLiteral
    | LPAREN expression RPAREN
    | NOT factor
    | (PLUS | MINUS) factor
    ;

identifier
    : IDENTIFIER
    ;

unsignedNumber
    : INTEGER_LITERAL
    | REAL_LITERAL
    ;

stringLiteral
    : STRING_LITERAL
    ;

boolLiteral
    : TRUE
    | FALSE
    ;

// ===== REGRAS DO LEXER (Tokens) =====

// Palavras-reservadas
PROGRAM     : 'program';
VAR         : 'var';
BEGIN       : 'begin';
END         : 'end';
IF          : 'if';
THEN        : 'then';
ELSE        : 'else';
WHILE       : 'while';
DO          : 'do';
FOR         : 'for';
TO          : 'to';
DOWNTO      : 'downto';
READ        : 'read';
PRINT       : 'print';
INTEGER_TYPE: 'integer';
REAL_TYPE   : 'real';
STRING_TYPE : 'string';
BOOLEAN_TYPE: 'boolean';
TRUE        : 'true';
FALSE       : 'false';
AND         : 'and';
OR          : 'or';
NOT         : 'not';

// Operadores
ASSIGN      : ':=';
EQUAL       : '=';
NOT_EQUAL   : '<>';
LESS_THAN   : '<';
LESS_EQUAL  : '<=';
GREATER_THAN: '>';
GREATER_EQUAL: '>=';
PLUS        : '+';
MINUS       : '-';
MULTIPLY    : '*';
DIVIDE      : '/';

// Delimitadores
LPAREN      : '(';
RPAREN      : ')';
SEMICOLON   : ';';
COLON       : ':';
COMMA       : ',';
DOT         : '.';

// Literais
IDENTIFIER
    : [a-zA-Z_][a-zA-Z0-9_]*
    ;

INTEGER_LITERAL
    : [0-9]+
    ;

REAL_LITERAL
    : [0-9]+ '.' [0-9]+
    ;

STRING_LITERAL
    : '\'' (~['\r\n])* '\''
    ;

// ComentÃ¡rios e espaÃ§os em branco
COMMENT
    : '{' .*? '}' -> skip
    | '(*' .*? '*)' -> skip
    | '//' ~[\r\n]* -> skip
    ;

WS
    : [ \t\r\n]+ -> skip
    ;


âœ… Exemplos de CÃ³digo VÃ¡lido

Exemplo 1: Programa Completo com Todos os Recursos

program exemploValido;
var
    x, y: integer;
    z: real;
begin
    read(x, y);
    z := x + y * 2;
    if z > 10 then
        print('maior que 10', z)
    else
        print('menor ou igual a 10', z);
    for x := 1 to 5 do
        print(x);
end.

AnÃ¡lise:
âœ… DeclaraÃ§Ã£o de programa: program exemploValido;
âœ… DeclaraÃ§Ã£o de mÃºltiplas variÃ¡veis: x, y: integer; e z: real;
âœ… Entrada de dados: read(x, y);
âœ… ExpressÃ£o aritmÃ©tica com precedÃªncia: x + y * 2 â†’ x + (y * 2)
âœ… Condicional completa: if-then-else
âœ… SaÃ­da com mÃºltiplos valores: print('maior que 10', z)
âœ… LaÃ§o for crescente: for x := 1 to 5 do
âœ… FinalizaÃ§Ã£o correta: end.

Exemplo 2: AtribuiÃ§Ã£o e SaÃ­da Simples

program Exemplo1;
var
    x, y : integer;
begin
    x := 10;
    y := x + 5;
    print(x, y);
end.

AnÃ¡lise:
âœ… AtribuiÃ§Ãµes simples
âœ… ExpressÃ£o aritmÃ©tica bÃ¡sica
âœ… SaÃ­da de mÃºltiplos valores
SaÃ­da Esperada:
10 15

Exemplo 3: Condicional com Entrada de Dados

program Exemplo2;
var
    nota : real;
begin
    read(nota);
    if nota >= 7.0 then
        print('Aprovado')
    else
        print('Reprovado');
end.

AnÃ¡lise:
âœ… VariÃ¡vel do tipo real
âœ… Entrada de dados do usuÃ¡rio
âœ… ComparaÃ§Ã£o relacional: >=
âœ… Strings literais em aspas simples
âœ… Estrutura if-then-else completa
ExecuÃ§Ã£o:

Entrada: 8.5
SaÃ­da: Aprovado

Entrada: 5.0
SaÃ­da: Reprovado

Exemplo 4: LaÃ§o While com Bloco Composto

program Exemplo3;
var
    i : integer;
begin
    i := 1;
    while i <= 5 do
    begin
        print('Valor de i:', i);
        i := i + 1;
    end;
end.

AnÃ¡lise:
âœ… LaÃ§o while com condiÃ§Ã£o
âœ… Bloco composto: begin...end dentro do while
âœ… Incremento de variÃ¡vel
âœ… SaÃ­da com string e variÃ¡vel
SaÃ­da Esperada:

Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5

Exemplo 5: LaÃ§os For Crescente e Decrescente

program Exemplo4;
var
    i : integer;
begin
    for i := 1 to 3 do
        print('Contando:', i);

    for i := 3 downto 1 do
        print('Decrescendo:', i);
end.

AnÃ¡lise:
âœ… LaÃ§o for crescente com to
âœ… LaÃ§o for decrescente com downto
âœ… MÃºltiplos comandos sequenciais
SaÃ­da Esperada:

Contando: 1
Contando: 2
Contando: 3
Decrescendo: 3
Decrescendo: 2
Decrescendo: 1

âŒ Exemplos de CÃ³digo InvÃ¡lido
Erro Completo: MÃºltiplos Erros SintÃ¡ticos

program exemploInvalido
var
    x, y integer     { ERRO: falta ":" entre identificadores e tipo }
    z: real

begin
    read(x y);       { ERRO: falta "," entre os parÃ¢metros }
    z := x + ;       { ERRO: expressÃ£o incompleta, operador sem operando }
    if z > 10        { ERRO: falta "then" }
        print('maior que 10', z)
    else
        print('menor ou igual a 10' z);  { ERRO: falta "," antes de z }

    for i := 1 to 5  { ERRO: variÃ¡vel i nÃ£o declarada e falta "do" }
        print(i)
end                  { ERRO: falta "." ao final do programa }


Erros Identificados:

Linha 1: Falta ; apÃ³s o nome do programa
Linha 3: Falta : na declaraÃ§Ã£o de variÃ¡vel
Linha 7: Falta , entre parÃ¢metros do read
Linha 8: ExpressÃ£o incompleta (x +)
Linha 9: Falta palavra-reservada then
Linha 12: Falta , antes de z
Linha 14: VariÃ¡vel i nÃ£o declarada
Linha 14: Falta palavra-reservada do
Linha 16: Falta . ao final do programa

Erro 1: Falta de Ponto Final
program Erro1;
begin
    print('Sem ponto final')
end   // âŒ ERRO: falta o "."

Erro: Programa deve terminar com . apÃ³s end

CorreÃ§Ã£o:
program Erro1;
begin
    print('Sem ponto final')
end.  // âœ… Correto

Erro 2: VariÃ¡vel NÃ£o Declarada
program Erro2;
begin
    x := 10;   // âŒ ERRO: "x" nÃ£o foi declarado
end.

Erro: VariÃ¡vel x usada sem declaraÃ§Ã£o prÃ©via

CorreÃ§Ã£o:
program Erro2;
var
    x: integer;  // âœ… DeclaraÃ§Ã£o adicionada
begin
    x := 10;
end.

Erro 3: Falta de THEN
program Erro3;
var
    a : integer;
begin
    if a = 10 print('Erro');  // âŒ ERRO: falta "then"
end.

Erro: Condicional if sem palavra-reservada then

CorreÃ§Ã£o:
program Erro3;
var
    a : integer;
begin
    if a = 10 then print('Erro');  // âœ… Correto
end.

Erro 4: Incompatibilidade de Tipos (Erro SemÃ¢ntico)
program Erro4;
var
    x : integer;
begin
    x := 'texto';   // âŒ ERRO: atribuiÃ§Ã£o invÃ¡lida (string em variÃ¡vel integer)
end.

Erro: Tipo incompatÃ­vel na atribuiÃ§Ã£o (detectado na anÃ¡lise semÃ¢ntica, nÃ£o sintÃ¡tica)

CorreÃ§Ã£o:
program Erro4;
var
    x : string;  // âœ… Tipo correto
begin
    x := 'texto';
end.

Ou:

program Erro4;
var
    x : integer;
begin
    x := 123;  // âœ… Valor compatÃ­vel
end.


ğŸ“Š PrecedÃªncia de Operadores
A precedÃªncia define a ordem de avaliaÃ§Ã£o das operaÃ§Ãµes em expressÃµes complexas.

| PrecedÃªncia    | Operadores                        | Tipo            | Associatividade | Exemplo                     |
|----------------|-----------------------------------|-----------------|-----------------|-----------------------------|
| 1 (Mais alta)  | `not`, `+` (unÃ¡rio), `-` (unÃ¡rio) | UnÃ¡rios         | Direita         | `not true`, `-x`, `+5`      |
| 2              | `*`, `/`, `and`                   | Multiplicativos | Esquerda        | `a * b`, `x / y`, `p and q` |
| 3              | `+`, `-`, `or`                    | Aditivos        | Esquerda        | `a + b`, `x - y`, `p or q`  |
| 4 (Mais baixa) | `=`, `<>`, `<`, `<=`, `>`, `>=`   | Relacionais     | NÃ£o associativo | `a = b`, `x > 10`           |

Exemplos de AvaliaÃ§Ã£o

Exemplo 1: PrecedÃªncia de MultiplicaÃ§Ã£o
z := 10 + 5 * 2;

AvaliaÃ§Ã£o:
1. 5 * 2 = 10    (multiplicaÃ§Ã£o primeiro)
2. 10 + 10 = 20  (depois adiÃ§Ã£o)
Resultado: z = 20

Exemplo 2: Uso de ParÃªnteses
z := (10 + 5) * 2;

AvaliaÃ§Ã£o:
1. (10 + 5) = 15  (parÃªnteses primeiro)
2. 15 * 2 = 30    (depois multiplicaÃ§Ã£o)
Resultado: z = 30

Exemplo 3: Operadores LÃ³gicos
resultado := not x and y;

AvaliaÃ§Ã£o:
1. not x          (not tem maior precedÃªncia)
2. (not x) and y  (depois and)

Exemplo 4: Operadores Relacionais
valido := x + 5 > y * 2;

AvaliaÃ§Ã£o:
1. x + 5          (expressÃ£o aritmÃ©tica esquerda)
2. y * 2          (expressÃ£o aritmÃ©tica direita)
3. (x + 5) > (y * 2)  (comparaÃ§Ã£o relacional)

ğŸš€ Como Gerar o Parser/Lexer
PrÃ©-requisitos
Certifique-se de ter instalado:
âœ… Java JDK 17 ou superior
âœ… Maven 3.9+
âœ… VariÃ¡vel de ambiente JAVA_HOME configurada

Passo 1: Gerar CÃ³digo com ANTLR
Execute o comando Maven para gerar o parser e lexer:
mvn clean generate-sources

SaÃ­da esperada:
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------< minipascal:compilador-minipascal >------------------
[INFO] Building compilador-minipascal 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- clean:3.2.0:clean (default-clean) @ compilador-minipascal ---
[INFO] Deleting C:\...\target
[INFO] 
[INFO] --- antlr4:4.13.1:antlr4 (antlr) @ compilador-minipascal ---
[INFO] ANTLR 4: Processing source directory C:\...\src\main\antlr4
[INFO] Processing grammar: miniPascal.g4
[INFO] 
[INFO] --- build-helper:3.6.0:add-source (add-source) @ compilador-minipascal ---
[INFO] Source directory: C:\...\target\generated-sources\antlr4 added.
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------

Passo 2: Verificar Arquivos Gerados
Navegue atÃ© o diretÃ³rio de arquivos gerados:
cd target/generated-sources/antlr4
dir  # Windows
ls   # Linux/Mac

Arquivos criados:
miniPascalLexer.java
miniPascalParser.java
miniPascalBaseVisitor.java
miniPascalVisitor.java
miniPascal.tokens
miniPascalLexer.tokens

Passo 3: Compilar o Projeto
mvn compile

SaÃ­da esperada:
[INFO] --- compiler:3.13.0:compile (default-compile) @ compilador-minipascal ---
[INFO] Compiling 11 source files
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------

Passo 4: Executar o Menu Interativo
java -cp target/classes Main
ou
mvn exec:java

Menu exibido:
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   ğŸš€ MINI-PASCAL COMPILADOR - IFS Itabaiana 2025.2    â•‘
â•‘        Menu de ExecuÃ§Ã£o das Entregas                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ ESCOLHA UMA OPÃ‡ÃƒO:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1 - Entrega 1: Gerar parser/lexer (mvn generate-sources)
2 - Entrega 2: Compilar projeto (mvn compile)
3 - Entrega 3: Rodar todos os testes (mvn test)
4 - Testes apenas do Lexer
5 - Testes apenas do Parser
6 - Limpar projeto (mvn clean)
7 - Demo SemÃ¢ntica (tabela de sÃ­mbolos + escopos)
8 - Entrega 4: GeraÃ§Ã£o de CÃ³digo IntermediÃ¡rio (C3E)
9 - ğŸ“‚ Ver localizaÃ§Ã£o dos relatÃ³rios de testes
0 - Sair
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
OpÃ§Ã£o:

Selecione a OpÃ§Ã£o 1 para gerar o parser/lexer novamente.

âœ… ValidaÃ§Ã£o e Testes

Teste 1: Verificar GeraÃ§Ã£o de Arquivos
ApÃ³s executar mvn generate-sources, verifique se os arquivos foram criados:
ls -la target/generated-sources/antlr4/

Resultado esperado:
miniPascalLexer.java
miniPascalParser.java
miniPascalBaseVisitor.java
miniPascalVisitor.java
miniPascal.tokens
miniPascalLexer.tokens

Teste 2: Compilar sem Erros
mvn clean compile
Resultado esperado:
[INFO] BUILD SUCCESS

Teste 3: Validar CÃ³digo VÃ¡lido
Crie um arquivo de teste teste_valido.pas:
program TesteValido;
var
    x: integer;
begin
    x := 10;
    print(x);
end.

Execute o parser (apÃ³s implementar testes na Entrega 2):
mvn test -Dtest=MiniPascalParserTest#testProgramaValido

Teste 4: Validar CÃ³digo InvÃ¡lido
Crie um arquivo de teste teste_invalido.pas:
program TesteInvalido
var
    x: integer
begin
    x := 10
end

Erros esperados:
Falta ; apÃ³s nome do programa
Falta ; apÃ³s declaraÃ§Ã£o de variÃ¡vel
Falta ; apÃ³s atribuiÃ§Ã£o
Falta . ao final do programa

ğŸ¯ Checklist de Entrega

DocumentaÃ§Ã£o
âœ… GramÃ¡tica BNF/EBNF completa documentada
âœ… ExplicaÃ§Ã£o de cada regra sintÃ¡tica
âœ… Exemplos de cÃ³digo vÃ¡lido (5 exemplos)
âœ… Exemplos de cÃ³digo invÃ¡lido com erros explicados (5 exemplos)
âœ… PrecedÃªncia de operadores documentada
âœ… Comandos suportados especificados

ImplementaÃ§Ã£o
âœ… Arquivo miniPascal.g4 criado e funcional
âœ… Parser e Lexer gerados com sucesso pelo ANTLR
âœ… Projeto compila sem erros (mvn compile)
âœ… Arquivos gerados localizados em target/generated-sources/antlr4/

Testes
âœ… GeraÃ§Ã£o de parser/lexer validada
âœ… CompilaÃ§Ã£o do projeto validada
âœ… Menu interativo funcional

Entrega
âœ… README_ENTREGA1.md completo
âœ… CÃ³digo-fonte versionado no Git
âœ… DocumentaÃ§Ã£o clara e organizada

ğŸ“ SuportePara dÃºvidas sobre esta entrega:
Email: jeds@outlook.com.br
GitHub: https://github.com/jeds2025
Equipe:
Enaldo Dantas  - jose.santos259@academico.ifs.edu.br
Agnaldo Neto   - jose.neto044@academico.ifs.edu.br
Vitorio Mota   - vitorio.mota085@academico.ifs.edu.br
Lucas Oliveira - lucas.oliveira031@academico.ifs.edu.br

ğŸ“š ReferÃªncias
ANTLR 4 Documentation: https://www.antlr.org/
The Definitive ANTLR 4 Reference - Terence Parr
BNF/EBNF Notation: ISO/IEC 14977
Pascal Language Reference: ISO 7185
Compilers: Principles, Techniques, and Tools - Aho, Lam, Sethi, Ullman (Dragon Book)

## ğŸ“ HistÃ³rico de VersÃµes

| VersÃ£o | Data       | DescriÃ§Ã£o                 | Autor              |
|--------|------------|---------------------------|--------------------|
| 1.0    | 14/01/2026 | VersÃ£o inicial da entrega | Equipe Mini-Pascal |


Entrega 1 concluÃ­da com sucesso! âœ…
Desenvolvido para IFS Campus Itabaiana - 2025.2
Disciplina: LINGUAGENS FORMAIS, AUTÃ”MATOS E COMPILADORES
Professor: Marlos Tacio Silva
