# üìò Entrega 1: Gram√°tica da Linguagem (BNF/EBNF)

**Compilador Mini-Pascal - IFS Campus Itabaiana 2025.2**

*Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES*

---

## üìÖ Informa√ß√µes da Entrega

| Item | Descri√ß√£o |
|------|-----------|
| **N√∫mero da Entrega** | 1 |
| **Data de Entrega** | 14/01/2026 |
| **Objetivo** | Definir formalmente a Mini-Linguagem utilizando BNF/EBNF |
| **Status** | ‚úÖ Conclu√≠do |
| **Respons√°veis** | Enaldo Dantas, Agnaldo Neto, Vitorio Mota, Lucas Oliveira |

---

## üìã √çndice

- [Objetivo](#objetivo)
- [Conceito](#conceito)
- [Artefatos Entregues](#artefatos-entregues)
- [Gram√°tica BNF/EBNF Completa](#gram√°tica-bnfebnf-completa)
- [Comandos Suportados](#comandos-suportados)
- [Estrutura da Gram√°tica ANTLR](#estrutura-da-gram√°tica-antlr)
- [Exemplos de C√≥digo V√°lido](#exemplos-de-c√≥digo-v√°lido)
- [Exemplos de C√≥digo Inv√°lido](#exemplos-de-c√≥digo-inv√°lido)
- [Preced√™ncia de Operadores](#preced√™ncia-de-operadores)
- [Como Gerar o Parser/Lexer](#como-gerar-o-parserlexer)
- [Valida√ß√£o e Testes](#valida√ß√£o-e-testes)
- [Checklist de Entrega](#checklist-de-entrega)

---

## üéØ Objetivo

Definir as **"regras do jogo"** da linguagem Mini-Pascal atrav√©s de uma gram√°tica formal que especifica:

- ‚úÖ **Estrutura de um programa v√°lido**: Como organizar declara√ß√µes e comandos
- ‚úÖ **Declara√ß√£o de vari√°veis e tipos**: Suporte a `integer`, `real`, `string`, `boolean`
- ‚úÖ **Comandos de controle**: Atribui√ß√£o, entrada/sa√≠da, condicionais e la√ßos
- ‚úÖ **Express√µes**: Aritm√©ticas, relacionais e l√≥gicas com preced√™ncia definida
- ‚úÖ **Regras l√©xicas**: Identificadores, n√∫meros, strings, palavras-reservadas

---

## üí° Conceito

A gram√°tica √© a **especifica√ß√£o formal** da linguagem Mini-Pascal. Ela define:

### 1. **Estrutura do Programa**
Todo programa Mini-Pascal segue a estrutura:

program ;
[var <declara√ß√µes>]
begin

end.


### 2. **Tipos de Dados Suportados**
- `integer` - N√∫meros inteiros
- `real` - N√∫meros reais (ponto flutuante)
- `string` - Cadeias de caracteres
- `boolean` - Valores l√≥gicos (`true`, `false`)

### 3. **Comandos Suportados**
- **Atribui√ß√£o**: `x := express√£o;`
- **Entrada**: `read(var1, var2, ...);`
- **Sa√≠da**: `print(expr1, expr2, ...);`
- **Condicional**: `if express√£o then comando [else comando]`
- **La√ßo While**: `while express√£o do comando`
- **La√ßo For**: `for var := expr to/downto expr do comando`

### 4. **Express√µes com Preced√™ncia**
- Operadores relacionais: `=`, `<>`, `<`, `<=`, `>`, `>=`
- Operadores aditivos: `+`, `-`, `or`
- Operadores multiplicativos: `*`, `/`, `and`
- Operadores un√°rios: `not`, `+` (un√°rio), `-` (un√°rio)

---

## üì¶ Artefatos Entregues

### Arquivos Principais

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| `miniPascal.g4` | `src/main/antlr4/` | Gram√°tica ANTLR completa do Mini-Pascal |
| `README_ENTREGA1.md` | Raiz do projeto | Este documento de entrega |

### Arquivos Gerados (ap√≥s `mvn generate-sources`)

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| `miniPascalLexer.java` | `target/generated-sources/antlr4/` | Analisador l√©xico gerado pelo ANTLR |
| `miniPascalParser.java` | `target/generated-sources/antlr4/` | Analisador sint√°tico gerado pelo ANTLR |
| `miniPascalBaseVisitor.java` | `target/generated-sources/antlr4/` | Classe base para visitor pattern |
| `miniPascalVisitor.java` | `target/generated-sources/antlr4/` | Interface do visitor pattern |
| `miniPascal.tokens` | `target/generated-sources/antlr4/` | Arquivo de tokens gerados |
| `miniPascalLexer.tokens` | `target/generated-sources/antlr4/` | Tokens do lexer |

---

## üìù Gram√°tica BNF/EBNF Completa

### Nota√ß√£o Utilizada

- `"texto"` - Terminal (palavra-reservada ou s√≠mbolo)
- `regra` - N√£o-terminal
- `|` - Alternativa (ou)
- `[ ... ]` - Opcional (zero ou uma vez)
- `{ ... }` - Repeti√ß√£o (zero ou mais vezes)
- `( ... )` - Agrupamento

---

1. Programa e Bloco
```ebnf
program =
    "program", identifier, ";", block, "." ;

block =
    [ variable-declaration-part ], compound-statement ;

variable-declaration-part =
    "var", variable-declaration, { ";", variable-declaration }, ";" ;

variable-declaration =
    identifier-list, ":", type ;

identifier-list =
    identifier, { ",", identifier } ;

type =
    "integer"
  | "real"
  | "string"
  | "boolean" ;

identifier =
    letter, { letter | digit | "_" } ;




Descri√ß√£o:

Todo programa inicia com a palavra-reservada program seguida de um identificador
Declara√ß√µes de vari√°veis s√£o opcionais (indicado por [ ... ])
M√∫ltiplas vari√°veis podem ser declaradas em uma √∫nica linha separadas por v√≠rgula
O bloco principal (compound-statement) √© obrigat√≥rio
O programa termina com ponto final (.)

Exemplo:

program MeuPrograma;
var
    x, y: integer;
    z: real;
begin
    x := 10;
end.

2. Comandos

compound-statement =
    "begin", statement-list, "end" ;

statement-list =
    statement, { ";", statement } ;

statement =
    simple-statement
  | structured-statement
  | (* vazio *) ;

simple-statement =
    assignment-statement
  | io-statement ;

assignment-statement =
    identifier, ":=", expression ;

io-statement =
    "read", "(", identifier, { ",", identifier }, ")"
  | "print", "(", expression, { ",", expression }, ")" ;

structured-statement =
    if-statement
  | while-statement
  | for-statement
  | compound-statement ;

if-statement =
    "if", expression, "then", statement, [ "else", statement ] ;

while-statement =
    "while", expression, "do", statement ;

for-statement =
    "for", identifier, ":=", expression,
    ( "to" | "downto" ), expression,
    "do", statement ;

Descri√ß√£o:
Comandos Simples: Atribui√ß√£o (x := 10) e I/O (read, print)
Comandos Estruturados: Condicionais (if-then-else), la√ßos (while, for) e blocos compostos
Comandos Vazios: Permitidos (ponto e v√≠rgula duplo ;;)

Exemplos:
Atribui√ß√£o:
x := 10 + y * 2;

Entrada/Sa√≠da:
read(x, y);
print('Resultado:', x + y);

Condicional:
if x > 0 then
    y := 1
else
    y := 0;

La√ßo While:
while i < 10 do
    i := i + 1;

La√ßo For:
for i := 1 to 5 do
    print(i);

for i := 5 downto 1 do
    print(i);

3. Express√µes (com Preced√™ncia)

expression =
    simple-expression, [ relational-operator, simple-expression ] ;

relational-operator =
    "="  | "<>" | "<" | "<=" | ">" | ">=" ;

simple-expression =
    term, { additive-operator, term } ;

additive-operator =
    "+" | "-" | "or" ;

term =
    factor, { multiplicative-operator, factor } ;

multiplicative-operator =
    "*" | "/" | "and" ;

factor =
    identifier
  | unsigned-number
  | string-literal
  | boolean-literal
  | "(", expression, ")"
  | "not", factor
  | "+", factor
  | "-", factor ;


Descri√ß√£o:
A gram√°tica define a preced√™ncia de operadores atrav√©s da hierarquia de regras:
Express√µes relacionais (menor preced√™ncia): =, <>, <, <=, >, >=
Express√µes aditivas: +, -, or
Termos multiplicativos: *, /, and
Fatores (maior preced√™ncia): not, + (un√°rio), - (un√°rio), par√™nteses

Exemplos de Avalia√ß√£o:
z := 10 + 5 * 2;     // Equivale a: z := 10 + (5 * 2) = 20
z := (10 + 5) * 2;   // Equivale a: z := 15 * 2 = 30
z := not x and y;    // Equivale a: z := (not x) and y


4. L√©xico (Tokens B√°sicos)

unsigned-number =
    integer
  | real ;

integer =
    digit, { digit } ;

real =
    digit, { digit }, ".", digit, { digit } ;

string-literal =
    "'", { character - "'" | "''" }, "'" ;

boolean-literal =
    "true" | "false" ;

letter =
    "A" | "B" | ... | "Z"
  | "a" | "b" | ... | "z" ;

digit  =
    "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;


Descri√ß√£o:
N√∫meros Inteiros: Sequ√™ncia de d√≠gitos (123, 0, 999)
N√∫meros Reais: D√≠gitos, ponto, d√≠gitos (123.45, 0.5, 3.14159)
Strings: Delimitadas por aspas simples ('texto', 'Hello World')
Aspas simples dentro de strings s√£o escapadas duplicando: 'it''s' ‚Üí it's
Booleanos: Apenas true ou false
Identificadores: Iniciam com letra, podem conter letras, d√≠gitos e underscore (_)
V√°lidos: x, contador, valor_total, Nota1
Inv√°lidos: 1x (inicia com d√≠gito), x-y (h√≠fen n√£o permitido)

üõ†Ô∏è Comandos Suportados

ComandoSintaxeDescri√ß√£oExemploAtribui√ß√£ovar := expr;Atribui valor a uma vari√°velx := 10 + y * 2;Entradaread(var1, var2, ...);L√™ valores do usu√°rioread(x, y);Sa√≠daprint(expr1, expr2, ...);Imprime valores na telaprint('Resultado:', x);Condicionalif expr then cmd [else cmd]Executa comando condicionalmenteif x > 0 then y := 1 else y := 0;La√ßo Whilewhile expr do cmdRepete enquanto condi√ß√£o for verdadeirawhile i < 10 do i := i + 1;La√ßo For (crescente)for var := expr to expr do cmdLa√ßo com contador crescentefor i := 1 to 5 do print(i);La√ßo For (decrescente)for var := expr downto expr do cmdLa√ßo com contador decrescentefor i := 5 downto 1 do print(i);



üîß Estrutura da Gram√°tica ANTLR
Localiza√ß√£o do Arquivosrc/main/antlr4/miniPascal.g4
Estrutura Geral do Arquivo
O arquivo miniPascal.g4 est√° organizado em duas se√ß√µes principais:
Regras do Parser (sint√°ticas) - Definem a estrutura da linguagem
Regras do Lexer (l√©xicas) - Definem os tokens

Principais Regras do Parser

grammar miniPascal;

// ===== REGRAS DO PARSER (Sint√°ticas) =====

program
    : PROGRAM identifier SEMICOLON 
      variableDeclarationPart? 
      compoundStatement DOT EOF
    ;

variableDeclarationPart
    : VAR variableDeclaration (SEMICOLON variableDeclaration)* SEMICOLON?
    ;

variableDeclaration
    : identifierList COLON type
    ;

identifierList
    : identifier (COMMA identifier)*
    ;

type
    : INTEGER_TYPE
    | REAL_TYPE
    | STRING_TYPE
    | BOOLEAN_TYPE
    ;

compoundStatement
    : BEGIN statement (SEMICOLON statement)* END
    ;

statement
    : assignmentStatement
    | ifStatement
    | whileStatement
    | forStatement
    | ioStatement
    | compoundStatement
    | // comando vazio
    ;

assignmentStatement
    : identifier ASSIGN expression
    ;

ifStatement
    : IF expression THEN statement (ELSE statement)?
    ;

whileStatement
    : WHILE expression DO statement
    ;

forStatement
    : FOR identifier ASSIGN expression (TO | DOWNTO) expression DO statement
    ;

ioStatement
    : READ LPAREN identifierList RPAREN
    | PRINT LPAREN expressionList RPAREN
    ;

expressionList
    : expression (COMMA expression)*
    ;

expression
    : simpleExpression (relationalOperator simpleExpression)?
    ;

relationalOperator
    : EQUAL
    | NOT_EQUAL
    | LESS_THAN
    | LESS_EQUAL
    | GREATER_THAN
    | GREATER_EQUAL
    ;

simpleExpression
    : term (additiveOperator term)*
    ;

additiveOperator
    : PLUS
    | MINUS
    | OR
    ;

term
    : factor (multiplicativeOperator factor)*
    ;

multiplicativeOperator
    : MULTIPLY
    | DIVIDE
    | AND
    ;

factor
    : identifier
    | unsignedNumber
    | stringLiteral
    | boolLiteral
    | LPAREN expression RPAREN
    | NOT factor
    | (PLUS | MINUS) factor
    ;

identifier
    : IDENTIFIER
    ;

unsignedNumber
    : INTEGER_LITERAL
    | REAL_LITERAL
    ;

stringLiteral
    : STRING_LITERAL
    ;

boolLiteral
    : TRUE
    | FALSE
    ;

// ===== REGRAS DO LEXER (Tokens) =====

// Palavras-reservadas
PROGRAM     : 'program';
VAR         : 'var';
BEGIN       : 'begin';
END         : 'end';
IF          : 'if';
THEN        : 'then';
ELSE        : 'else';
WHILE       : 'while';
DO          : 'do';
FOR         : 'for';
TO          : 'to';
DOWNTO      : 'downto';
READ        : 'read';
PRINT       : 'print';
INTEGER_TYPE: 'integer';
REAL_TYPE   : 'real';
STRING_TYPE : 'string';
BOOLEAN_TYPE: 'boolean';
TRUE        : 'true';
FALSE       : 'false';
AND         : 'and';
OR          : 'or';
NOT         : 'not';

// Operadores
ASSIGN      : ':=';
EQUAL       : '=';
NOT_EQUAL   : '<>';
LESS_THAN   : '<';
LESS_EQUAL  : '<=';
GREATER_THAN: '>';
GREATER_EQUAL: '>=';
PLUS        : '+';
MINUS       : '-';
MULTIPLY    : '*';
DIVIDE      : '/';

// Delimitadores
LPAREN      : '(';
RPAREN      : ')';
SEMICOLON   : ';';
COLON       : ':';
COMMA       : ',';
DOT         : '.';

// Literais
IDENTIFIER
    : [a-zA-Z_][a-zA-Z0-9_]*
    ;

INTEGER_LITERAL
    : [0-9]+
    ;

REAL_LITERAL
    : [0-9]+ '.' [0-9]+
    ;

STRING_LITERAL
    : '\'' (~['\r\n])* '\''
    ;

// Coment√°rios e espa√ßos em branco
COMMENT
    : '{' .*? '}' -> skip
    | '(*' .*? '*)' -> skip
    | '//' ~[\r\n]* -> skip
    ;

WS
    : [ \t\r\n]+ -> skip
    ;


‚úÖ Exemplos de C√≥digo V√°lido

Exemplo 1: Programa Completo com Todos os Recursos

program exemploValido;
var
    x, y: integer;
    z: real;
begin
    read(x, y);
    z := x + y * 2;
    if z > 10 then
        print('maior que 10', z)
    else
        print('menor ou igual a 10', z);
    for x := 1 to 5 do
        print(x);
end.

An√°lise:
‚úÖ Declara√ß√£o de programa: program exemploValido;
‚úÖ Declara√ß√£o de m√∫ltiplas vari√°veis: x, y: integer; e z: real;
‚úÖ Entrada de dados: read(x, y);
‚úÖ Express√£o aritm√©tica com preced√™ncia: x + y * 2 ‚Üí x + (y * 2)
‚úÖ Condicional completa: if-then-else
‚úÖ Sa√≠da com m√∫ltiplos valores: print('maior que 10', z)
‚úÖ La√ßo for crescente: for x := 1 to 5 do
‚úÖ Finaliza√ß√£o correta: end.

Exemplo 2: Atribui√ß√£o e Sa√≠da Simples

program Exemplo1;
var
    x, y : integer;
begin
    x := 10;
    y := x + 5;
    print(x, y);
end.

An√°lise:
‚úÖ Atribui√ß√µes simples
‚úÖ Express√£o aritm√©tica b√°sica
‚úÖ Sa√≠da de m√∫ltiplos valores
Sa√≠da Esperada:
10 15

Exemplo 3: Condicional com Entrada de Dados

program Exemplo2;
var
    nota : real;
begin
    read(nota);
    if nota >= 7.0 then
        print('Aprovado')
    else
        print('Reprovado');
end.

An√°lise:
‚úÖ Vari√°vel do tipo real
‚úÖ Entrada de dados do usu√°rio
‚úÖ Compara√ß√£o relacional: >=
‚úÖ Strings literais em aspas simples
‚úÖ Estrutura if-then-else completa
Execu√ß√£o:

Entrada: 8.5
Sa√≠da: Aprovado

Entrada: 5.0
Sa√≠da: Reprovado

Exemplo 4: La√ßo While com Bloco Composto

program Exemplo3;
var
    i : integer;
begin
    i := 1;
    while i <= 5 do
    begin
        print('Valor de i:', i);
        i := i + 1;
    end;
end.

An√°lise:
‚úÖ La√ßo while com condi√ß√£o
‚úÖ Bloco composto: begin...end dentro do while
‚úÖ Incremento de vari√°vel
‚úÖ Sa√≠da com string e vari√°vel
Sa√≠da Esperada:

Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5

Exemplo 5: La√ßos For Crescente e Decrescente

program Exemplo4;
var
    i : integer;
begin
    for i := 1 to 3 do
        print('Contando:', i);

    for i := 3 downto 1 do
        print('Decrescendo:', i);
end.

An√°lise:
‚úÖ La√ßo for crescente com to
‚úÖ La√ßo for decrescente com downto
‚úÖ M√∫ltiplos comandos sequenciais
Sa√≠da Esperada:

Contando: 1
Contando: 2
Contando: 3
Decrescendo: 3
Decrescendo: 2
Decrescendo: 1

‚ùå Exemplos de C√≥digo Inv√°lido
Erro Completo: M√∫ltiplos Erros Sint√°ticos

program exemploInvalido
var
    x, y integer     { ERRO: falta ":" entre identificadores e tipo }
    z: real

begin
    read(x y);       { ERRO: falta "," entre os par√¢metros }
    z := x + ;       { ERRO: express√£o incompleta, operador sem operando }
    if z > 10        { ERRO: falta "then" }
        print('maior que 10', z)
    else
        print('menor ou igual a 10' z);  { ERRO: falta "," antes de z }

    for i := 1 to 5  { ERRO: vari√°vel i n√£o declarada e falta "do" }
        print(i)
end                  { ERRO: falta "." ao final do programa }


Erros Identificados:



































































LinhaErroDescri√ß√£oCorre√ß√£o1Falta ;Ap√≥s nome do programaprogram exemploInvalido;3Falta :Entre identificadores e tipox, y: integer;4Falta ;Ap√≥s declara√ß√£o de vari√°velz: real;7Falta ,Entre par√¢metros do readread(x, y);8Express√£o incompletaOperador + sem operando direitoz := x + y;9Falta thenAp√≥s condi√ß√£o do ifif z > 10 then12Falta ,Antes do segundo argumentoprint('...', z);14Vari√°vel n√£o declaradai n√£o foi declaradaAdicionar i: integer;14Falta doAp√≥s express√£o do forfor i := 1 to 5 do16Falta .Ao final do programaend.






















