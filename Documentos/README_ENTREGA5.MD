# ğŸ“• Entrega 5: Ajustes Finais e ApresentaÃ§Ã£o

**Compilador Mini-Pascal - IFS Campus Itabaiana 2025.2**

*Disciplina: LINGUAGENS FORMAIS, AUTÃ”MATOS E COMPILADORES*

---

## ğŸ“… InformaÃ§Ãµes da Entrega

| Item            | DescriÃ§Ã£o                                 |
|-----------------|-------------------------------------------|
| Data de Entrega | 11/02/2026                                |
| Objetivo        | Compilador completo, polido e documentado |
| Status          | âœ… ConcluÃ­do                              |

---

## ğŸ“‹ Ãndice

- [Objetivo](#objetivo)
- [VisÃ£o Geral do Projeto](#visÃ£o-geral-do-projeto)
- [Arquitetura do Compilador](#arquitetura-do-compilador)
- [Componentes Implementados](#componentes-implementados)
- [Fluxo de CompilaÃ§Ã£o](#fluxo-de-compilaÃ§Ã£o)
- [Exemplos Completos](#exemplos-completos)
- [Testes e ValidaÃ§Ã£o](#testes-e-validaÃ§Ã£o)
- [Como Usar](#como-usar)
- [Melhorias Implementadas](#melhorias-implementadas)
- [LimitaÃ§Ãµes Conhecidas](#limitaÃ§Ãµes-conhecidas)
- [ApresentaÃ§Ã£o](#apresentaÃ§Ã£o)
- [ConclusÃ£o](#conclusÃ£o)

---

## ğŸ¯ Objetivo

Esta entrega final consolida **todas as etapas anteriores** em um compilador completo e funcional, atendendo aos seguintes requisitos:

- âœ… IntegraÃ§Ã£o Completa: UnificaÃ§Ã£o das fases LÃ©xica, SintÃ¡tica, SemÃ¢ntica e GeraÃ§Ã£o de CÃ³digo.
- âœ… Polimento: Refinamento de mensagens de erro e interface de usuÃ¡rio (CLI).
- âœ… ValidaÃ§Ã£o Final: Testes com programas complexos e casos de borda.
- âœ… DocumentaÃ§Ã£o: Guia completo de uso e arquitetura.
- âœ… Pronto para ApresentaÃ§Ã£o: DemonstraÃ§Ã£o ao vivo da traduÃ§Ã£o para CÃ³digo IntermediÃ¡rio (TAC).

---

## ğŸ’¡ VisÃ£o Geral do Projeto

### O que foi construÃ­do?

> "Um compilador completo para a linguagem **Mini-Pascal**, capaz de processar cÃ³digo-fonte desde a anÃ¡lise lÃ©xica atÃ© a geraÃ§Ã£o de cÃ³digo intermediÃ¡rio (Three-Address Code), com detecÃ§Ã£o robusta de erros e otimizaÃ§Ãµes bÃ¡sicas."

### CaracterÃ­sticas Principais

| CaracterÃ­stica       | DescriÃ§Ã£o                                                 |
|----------------------|-----------------------------------------------------------|
| Linguagem Fonte      | Mini-Pascal (subset educacional do Pascal)                |
| ImplementaÃ§Ã£o        | Java 11+ com ANTLR 4                                      |
| CÃ³digo IntermediÃ¡rio | Three-Address Code (TAC) / C3E                            |
| OtimizaÃ§Ãµes          | Constant folding, copy propagation, dead code elimination |
| Testes               | 28+ testes unitÃ¡rios (JUnit 5) com 100% de aprovaÃ§Ã£o      |
| DocumentaÃ§Ã£o         | README consolidado + 5 documentos de entrega detalhados   |

---

## ğŸ—ï¸ Arquitetura do Compilador

O compilador segue o modelo clÃ¡ssico de "front-end" e parte do "back-end":

1.  AnÃ¡lise LÃ©xica (Scanner): Converte caracteres em tokens (`miniPascalLexer`).
2.  AnÃ¡lise SintÃ¡tica (Parser): Converte tokens em uma AST (`miniPascalParser`).
3.  AnÃ¡lise SemÃ¢ntica: Valida tipos e escopos (`MiniPascalSemanticVisitor` + `SymbolTable`).
4.  GeraÃ§Ã£o de CÃ³digo: Traduz a AST para TAC (`MiniPascalCodeGenerator`).
5.  OtimizaÃ§Ã£o: Refina o cÃ³digo TAC gerado.

### Diagrama de Componentes



â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMPILADOR MINI-PASCAL                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FASE 1: ANÃLISE LÃ‰XICA (Scanner)                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Entrada: CÃ³digo-fonte (.pas)                               â”‚
â”‚  SaÃ­da: SequÃªncia de Tokens                                 â”‚
â”‚  Componente: miniPascalLexer.java (ANTLR)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FASE 2: ANÃLISE SINTÃTICA (Parser)                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Entrada: Tokens                                            â”‚
â”‚  SaÃ­da: Ãrvore SintÃ¡tica Abstrata (AST)                     â”‚
â”‚  Componente: miniPascalParser.java (ANTLR)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FASE 3: ANÃLISE SEMÃ‚NTICA                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Entrada: AST                                               â”‚
â”‚  SaÃ­da: AST validada + Tabela de SÃ­mbolos                   â”‚
â”‚  Componentes:                                               â”‚
â”‚    - MiniPascalSemanticVisitor.java                         â”‚
â”‚    - SymbolTable.java                                       â”‚
â”‚    - Type.java                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FASE 4: GERAÃ‡ÃƒO DE CÃ“DIGO INTERMEDIÃRIO                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Entrada: AST validada                                      â”‚
â”‚  SaÃ­da: CÃ³digo de TrÃªs EndereÃ§os (TAC)                      â”‚
â”‚  Componentes:                                               â”‚
â”‚    - Instruction.java                                       â”‚
â”‚    - MiniPascalCodeGenerator.java                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚  CÃ“DIGO FINAL   â”‚
                     â”‚  (TAC otimizado)â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

---

## ğŸ“¦ Componentes Implementados

### Resumo de Todos os Artefatos

| Componente         | Arquivo                          | LocalizaÃ§Ã£o                 | DescriÃ§Ã£o                                       |
|--------------------|----------------------------------|-----------------------------|-------------------------------------------------|
| GramÃ¡tica          | `miniPascal.g4`                  | `src/main/antlr4/`          | DefiniÃ§Ã£o BNF/EBNF da linguagem.                |
| Lexer/Parser       | Gerados pelo ANTLR               | `target/generated-sources/` | Analisadores gerados automaticamente.           |
| Visitor SemÃ¢ntico  | `MiniPascalSemanticVisitor.java` | `src/main/java/`            | ImplementaÃ§Ã£o da lÃ³gica semÃ¢ntica.              |
| Tabela de SÃ­mbolos | `SymbolTable.java`               | `src/main/java/`            | Gerenciamento de escopos aninhados.             |
| Gerador TAC        | `MiniPascalCodeGenerator.java`   | `src/main/java/`            | Tradutor da AST para CÃ³digo de 3 EndereÃ§os.     |
| InstruÃ§Ã£o TAC      | `Instruction.java`               | `src/main/java/`            | RepresentaÃ§Ã£o atÃ´mica (result, arg1, op, arg2). |
| Menu Principal     | `Main.java`                      | `src/main/java/`            | Interface interativa para o usuÃ¡rio.            |

---

ğŸš€ Como UsarPrÃ©-requisitos
Java JDK 17+
Maven 3.6+

InstalaÃ§Ã£o e ExecuÃ§Ã£o

Compilar o projeto:
   mvn clean compile

Iniciar o Menu Interativo:
   java -cp target/classes Main

ğŸ–¥ï¸ Menu de ExecuÃ§Ã£o (Implementado no Main.java)
Ao executar o projeto, vocÃª verÃ¡ as seguintes opÃ§Ãµes:

1 - Entrega 1: Gerar parser/lexer (mvn generate-sources)
2 - Entrega 2: Compilar projeto (mvn compile)
3 - Entrega 3: Rodar todos os testes (mvn test)
4 - Testes apenas do Lexer
5 - Testes apenas do Parser
6 - Limpar projeto (mvn clean)
7 - Demo SemÃ¢ntica (tabela de sÃ­mbolos + escopos)
8 - Entrega 4: GeraÃ§Ã£o de CÃ³digo IntermediÃ¡rio (C3E)
9 - Ver localizaÃ§Ã£o dos relatÃ³rios de testes
0 - Sair


## ğŸ”„ Fluxo de CompilaÃ§Ã£o (Exemplo)

**Entrada (Pascal):**
```pascal
x := 10 + 20 * 2;

SaÃ­da (TAC):

t0 = 20 * 2
t1 = 10 + t0
x = t1

---

### Exemplo Passo a Passo

**CÃ³digo-Fonte Mini-Pascal:**
```pascal
program Exemplo;
var
    x, y, resultado: integer;
begin
    x := 10;
    y := 20;
    resultado := x + y * 2;
    print('Resultado:', resultado);
end.


PASSO 1: AnÃ¡lise LÃ©xica
Entrada: CÃ³digo-fonte (texto)
SaÃ­da: SequÃªncia de Tokens

PROGRAM
IDENTIFIER(Exemplo)
SEMICOLON
VAR
IDENTIFIER(x)
COMMA
IDENTIFIER(y)
COMMA
IDENTIFIER(resultado)
COLON
INTEGER
SEMICOLON
BEGIN
IDENTIFIER(x)
ASSIGN
NUMBER(10)
SEMICOLON
IDENTIFIER(y)
ASSIGN
NUMBER(20)
SEMICOLON
IDENTIFIER(resultado)
ASSIGN
IDENTIFIER(x)
PLUS
IDENTIFIER(y)
MULTIPLY
NUMBER(2)
SEMICOLON
PRINT
LPAREN
STRING('Resultado:')
COMMA
IDENTIFIER(resultado)
RPAREN
SEMICOLON
END
DOT
EOF


PASSO 2: AnÃ¡lise SintÃ¡ticaE
ntrada: Tokens
SaÃ­da: Ãrvore SintÃ¡tica Abstrata (AST)

program
â”œâ”€â”€ PROGRAM Exemplo
â”œâ”€â”€ variableDeclarationPart
â”‚   â””â”€â”€ variableDeclaration
â”‚       â”œâ”€â”€ identifierList: x, y, resultado
â”‚       â””â”€â”€ type: integer
â””â”€â”€ compoundStatement
    â”œâ”€â”€ statement (assignmentStatement)
    â”‚   â”œâ”€â”€ identifier: x
    â”‚   â””â”€â”€ expression: 10
    â”œâ”€â”€ statement (assignmentStatement)
    â”‚   â”œâ”€â”€ identifier: y
    â”‚   â””â”€â”€ expression: 20
    â”œâ”€â”€ statement (assignmentStatement)
    â”‚   â”œâ”€â”€ identifier: resultado
    â”‚   â””â”€â”€ expression
    â”‚       â”œâ”€â”€ simpleExpression
    â”‚       â”‚   â”œâ”€â”€ term: x
    â”‚       â”‚   â””â”€â”€ term
    â”‚       â”‚       â”œâ”€â”€ factor: y
    â”‚       â”‚       â””â”€â”€ factor: 2
    â””â”€â”€ statement (ioStatement)
        â””â”€â”€ print('Resultado:', resultado)



PASSO 3: AnÃ¡lise SemÃ¢ntica
Entrada: AST
### ValidaÃ§Ãµes Realizadas:

| VerificaÃ§Ã£o                        | Resultado                |
|------------------------------------|--------------------------|
| VariÃ¡vel `x` declarada?            | âœ… Sim (linha 3)        |
| VariÃ¡vel `y` declarada?            | âœ… Sim (linha 3)        |
| VariÃ¡vel `resultado` declarada?    | âœ… Sim (linha 3)        |
| Tipo de `x + y * 2`?               | âœ… INTEGER (compatÃ­vel) |
| AtribuiÃ§Ã£o `resultado := INTEGER`? | âœ… VÃ¡lida               |


SaÃ­da: AST validada + Tabela de SÃ­mbolos
Tabela de SÃ­mbolos:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VariÃ¡vel   â”‚   Tipo   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x            â”‚ INTEGER  â”‚
â”‚ y            â”‚ INTEGER  â”‚
â”‚ resultado    â”‚ INTEGER  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


PASSO 4: GeraÃ§Ã£o de CÃ³digo IntermediÃ¡rio
Entrada: AST validada
SaÃ­da: CÃ³digo de TrÃªs EndereÃ§os (TAC)

x = 10
y = 20
t1 = y * 2
t2 = x + t1
resultado = t2
print "Resultado:"
print resultado


PASSO 5: OtimizaÃ§Ã£o (Opcional)
Entrada: CÃ³digo TAC
OtimizaÃ§Ãµes Aplicadas:
âœ… Constant Folding: t1 = 20 * 2 â†’ t1 = 40
âœ… Copy Propagation: resultado = t2 â†’ resultado = 50
SaÃ­da: CÃ³digo TAC Otimizado

x = 10
y = 20
resultado = 50
print "Resultado:"
print resultado


âœ… Exemplos Completos
Exemplo 1: Programa com If-Else
CÃ³digo Mini-Pascal:
program TesteCondicional;
var
    idade: integer;
    categoria: string;
begin
    read(idade);
    
    if idade < 18 then
        categoria := 'Menor de idade'
    else
        categoria := 'Maior de idade';
    
    print('Categoria:', categoria);
end.

CÃ³digo TAC Gerado:
read idade
t1 = idade < 18
if t1 == 0 goto L1
categoria = "Menor de idade"
goto L2
L1:
categoria = "Maior de idade"
L2:
print "Categoria:"
print categoria


Exemplo 2: Programa com While
CÃ³digo Mini-Pascal:
program SomaAte10;
var
    i, soma: integer;
begin
    i := 1;
    soma := 0;
    
    while i <= 10 do
    begin
        soma := soma + i;
        i := i + 1;
    end;
    
    print('Soma:', soma);
end.

CÃ³digo TAC Gerado:
i = 1
soma = 0
L1:
t1 = i <= 10
if t1 == 0 goto L2
t2 = soma + i
soma = t2
t3 = i + 1
i = t3
goto L1
L2:
print "Soma:"
print soma


Exemplo 3: Programa com For (crescente)
CÃ³digo Mini-Pascal:
program Fatorial;
var
    i, n, resultado: integer;
begin
    n := 5;
    resultado := 1;
    
    for i := 1 to n do
        resultado := resultado * i;
    
    print('Fatorial de', n, '=', resultado);
end.

CÃ³digo TAC Gerado:
n = 5
resultado = 1
i = 1
L1:
t1 = i <= n
if t1 == 0 goto L2
t2 = resultado * i
resultado = t2
t3 = i + 1
i = t3
goto L1
L2:
print "Fatorial de"
print n
print "="
print resultado


Exemplo 4: Programa com For (decrescente)
CÃ³digo Mini-Pascal:
program ContagemRegressiva;
var
    i: integer;
begin
    for i := 10 downto 1 do
        print(i);
    
    print('Fim!');
end.

CÃ³digo TAC Gerado:
i = 10
L1:
t1 = i >= 1
if t1 == 0 goto L2
print i
t2 = i - 1
i = t2
goto L1
L2:
print "Fim!"


Exemplo 5: Programa Complexo (Calculadora de MÃ©dia)
CÃ³digo Mini-Pascal:
program CalculadoraMedia;
var
    nota1, nota2, nota3, media: real;
    situacao: string;
begin
    print('Digite 3 notas:');
    read(nota1, nota2, nota3);
    
    media := (nota1 + nota2 + nota3) / 3;
    
    if media >= 7.0 then
        situacao := 'Aprovado'
    else
        if media >= 5.0 then
            situacao := 'Recuperacao'
        else
            situacao := 'Reprovado';
    
    print('Media:', media);
    print('Situacao:', situacao);
end.

CÃ³digo TAC Gerado:
print "Digite 3 notas:"
read nota1
read nota2
read nota3
t1 = nota1 + nota2
t2 = t1 + nota3
t3 = t2 / 3
media = t3
t4 = media >= 7.0
if t4 == 0 goto L1
situacao = "Aprovado"
goto L2
L1:
t5 = media >= 5.0
if t5 == 0 goto L3
situacao = "Recuperacao"
goto L4
L3:
situacao = "Reprovado"
L4:
L2:
print "Media:"
print media
print "Situacao:"
print situacao


## ğŸ§ª Testes e ValidaÃ§Ã£o

### SuÃ­te de Testes Completa

| Categoria         | Testes    | Status            |
|-------------------|-----------|-------------------|
| AnÃ¡lise LÃ©xica    |  6 testes | âœ… 100% passando |
| AnÃ¡lise SintÃ¡tica |  6 testes | âœ… 100% passando |
| AnÃ¡lise SemÃ¢ntica |  4 testes | âœ… 100% passando |
| GeraÃ§Ã£o de CÃ³digo |  8 testes | âœ… 100% passando |
| TOTAL             | 24 testes | âœ… 100% passando |


Executar Todos os Testes

# Executar toda a suÃ­te de testes
mvn test


## ğŸš€ Como Usar

### PrÃ©-requisitos

| Requisito | VersÃ£o MÃ­nima |
|-----------|---------------|
| Java JDK  | 17+           |
| Maven     | 3.6+          |
| Git       | 2.0+          |


InstalaÃ§Ã£o
# 1. Clonar o repositÃ³rio
git clone https://github.com/ifs2026/mini-pascal.git
cd compilador-minipascal

# 2. Compilar o projeto
mvn clean compile

# 3. Executar testes (opcional)
mvn test


Uso Interativo (Menu)
# Executar o menu principal
java -cp target/classes Main

Menu de OpÃ§Ãµes:

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       COMPILADOR MINI-PASCAL - IFS 2025.2              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Escolha uma opÃ§Ã£o:

1 - Compilar arquivo .pas (caminho completo)
2 - Testes apenas do Lexer
3 - Testes apenas do Parser
4 - Testes de AnÃ¡lise SemÃ¢ntica
5 - Testes do Gerador de CÃ³digo IntermediÃ¡rio
6 - CompilaÃ§Ã£o Completa (Lexer + Parser + SemÃ¢ntica + TAC)
7 - Demo SemÃ¢ntica (tabela de sÃ­mbolos + escopos)
8 - Demo Gerador TAC (cÃ³digo intermediÃ¡rio)
9 - Executar todos os testes
0 - Sair

Digite sua opÃ§Ã£o:


Uso via Linha de Comando

# Compilar um arquivo especÃ­fico
java -cp target/classes Main compile exemplos/programa.pas

# Gerar apenas cÃ³digo TAC
java -cp target/classes Main tac exemplos/programa.pas

# Executar com otimizaÃ§Ãµes
java -cp target/classes Main compile exemplos/programa.pas --optimize



Estrutura de Arquivos de Entrada
Arquivo: exemplos/programa.pas

program MeuPrograma;
var
    x, y: integer;
begin
    x := 10;
    y := 20;
    print(x + y);
end.

Executar:
java -cp target/classes Main compile exemplos/programa.pas
SaÃ­da:
âœ… CompilaÃ§Ã£o concluÃ­da com sucesso!

ğŸ“„ CÃ³digo TAC gerado em: output/programa.tac

ConteÃºdo:
x = 10
y = 20
t1 = x + y
print t1


Exemplo de Mensagem de Erro Melhorada
CÃ³digo com Erro:
program Erro;
var x: integer;
begin
    y := 10;  // âŒ VariÃ¡vel 'y' nÃ£o declarada
end.

Mensagem de Erro:
âŒ ERRO SEMÃ‚NTICO na linha 4, coluna 5:
   Variavel 'y' nao declarada

   4 |     y := 10;
     |     ^

ğŸ’¡ SugestÃ£o: Verifique se a variÃ¡vel foi declarada na seÃ§Ã£o 'var'.
   VariÃ¡veis declaradas: x




## âš ï¸ LimitaÃ§Ãµes Conhecidas

### Funcionalidades NÃ£o Implementadas (Conforme Escopo)

| Funcionalidade        | Status              | Justificativa                            |
|-----------------------|---------------------|------------------------------------------|
| FunÃ§Ãµes/Procedimentos | âŒ NÃ£o implementado | Fora do escopo do projeto                |
| Arrays/Vetores        | âŒ NÃ£o implementado | Fora do escopo do projeto                |
| Structs/Records       | âŒ NÃ£o implementado | Fora do escopo do projeto                |
| Ponteiros             | âŒ NÃ£o implementado | Fora do escopo do projeto                |
| GeraÃ§Ã£o de Assembly   | âŒ NÃ£o implementado | Etapa futura (nÃ£o coberta na disciplina) |
| GeraÃ§Ã£o de ExecutÃ¡vel | âŒ NÃ£o implementado | Etapa futura (nÃ£o coberta na disciplina) |

### LimitaÃ§Ãµes TÃ©cnicas

| LimitaÃ§Ã£o        | DescriÃ§Ã£o                                       | Workaround                                 |
|------------------|-------------------------------------------------|--------------------------------------------|
| Tipo STRING      | OperaÃ§Ãµes limitadas (apenas atribuiÃ§Ã£o e print) | Usar apenas para saÃ­da                     |
| DivisÃ£o por Zero | Detectada apenas em constantes                  | Adicionar validaÃ§Ã£o em runtime futuramente |
| Overflow         | NÃ£o hÃ¡ verificaÃ§Ã£o de overflow de inteiros      | Usar valores dentro do range de `int`      |
| RecursÃ£o         | NÃ£o suportada (sem funÃ§Ãµes)                     | N/A                                        |

ğŸ¤ ApresentaÃ§Ã£o
Roteiro de DemonstraÃ§Ã£o
DuraÃ§Ã£o: 10-15 minutos

1ï¸âƒ£ IntroduÃ§Ã£o (2 min)
Apresentar a equipe
Explicar o objetivo do projeto
Mostrar a linguagem Mini-Pascal

2ï¸âƒ£ DemonstraÃ§Ã£o ao Vivo (8 min)
Exemplo 1: Programa Simples
program Ola;
begin
    print('OlÃ¡, Mundo!');
end.

Mostrar anÃ¡lise lÃ©xica (tokens)
Mostrar anÃ¡lise sintÃ¡tica (AST)
Mostrar cÃ³digo TAC gerado


Exemplo 2: Programa com Erro
program Erro;
begin
    x := 10;  // Erro: variÃ¡vel nÃ£o declarada
end.

Demonstrar detecÃ§Ã£o de erro semÃ¢ntico
Mostrar mensagem de erro clara


Exemplo 3: Programa Complexo
program Fatorial;
var i, n, resultado: integer;
begin
    n := 5;
    resultado := 1;
    for i := 1 to n do
        resultado := resultado * i;
    print('Fatorial:', resultado);
end.

Mostrar cÃ³digo TAC completo
Demonstrar otimizaÃ§Ãµes aplicadas


3ï¸âƒ£ Arquitetura e Testes (3 min)
Explicar arquitetura do compilador
Mostrar cobertura de testes (28 testes, 100% passando)
Demonstrar execuÃ§Ã£o da suÃ­te de testes

4ï¸âƒ£ ConclusÃ£o (2 min)
Resumir o que foi implementado
Destacar desafios enfrentados
Mencionar aprendizados




Slides da ApresentaÃ§Ã£o
Slide 1: TÃ­tulo
COMPILADOR MINI-PASCAL
IFS Campus Itabaiana - 2025.2

Equipe:
- Enaldo Dantas
- Agnaldo Neto
- Vitorio Mota
- Lucas Oliveira


Slide 2: VisÃ£o Geral
âœ… Linguagem: Mini-Pascal
âœ… Fases: LÃ©xica, SintÃ¡tica, SemÃ¢ntica, GeraÃ§Ã£o de CÃ³digo
âœ… CÃ³digo IntermediÃ¡rio: Three-Address Code (TAC)
âœ… Testes: 28 testes unitÃ¡rios (100% passando)
âœ… Linhas de CÃ³digo: ~3.500 linhas (Java)


Slide 3: Arquitetura[
Diagrama de componentes do compilador]

Slide 4: DemonstraÃ§Ã£o
[CÃ³digo de exemplo ao vivo]

Slide 5: Resultados
ğŸ“Š EstatÃ­sticas:
- 40+ tipos de tokens
- 30+ regras gramaticais
- 4 tipos de dados
- 11 tipos de instruÃ§Ãµes TAC
- 4 tÃ©cnicas de otimizaÃ§Ã£o




## ğŸ“ ConclusÃ£o

### O que foi AlcanÃ§ado

| Objetivo                         | Status              |
|----------------------------------|---------------------|
| Implementar analisador lÃ©xico    | âœ… Completo         |
| Implementar analisador sintÃ¡tico | âœ… Completo         |
| Implementar analisador semÃ¢ntico | âœ… Completo         |
| Gerar cÃ³digo intermediÃ¡rio (TAC) | âœ… Completo         |
| Aplicar otimizaÃ§Ãµes              | âœ… Completo         |
| Criar testes unitÃ¡rios           | âœ… 28 testes (100%) |
| Documentar o projeto             | âœ… Completo         |
| Apresentar o compilador          | âœ… Pronto           |

Aprendizados
Conceitos de Compiladores:
âœ… AnÃ¡lise lÃ©xica e tokenizaÃ§Ã£o
âœ… GramÃ¡ticas formais (BNF/EBNF)
âœ… Ãrvores sintÃ¡ticas abstratas (AST)
âœ… AnÃ¡lise semÃ¢ntica e tabela de sÃ­mbolos
âœ… GeraÃ§Ã£o de cÃ³digo intermediÃ¡rio
âœ… OtimizaÃ§Ãµes de cÃ³digo

Engenharia de Software:
âœ… Arquitetura modular e orientada a objetos
âœ… Testes unitÃ¡rios e TDD
âœ… Controle de versÃ£o (Git/GitHub)
âœ… DocumentaÃ§Ã£o tÃ©cnica

Ferramentas:
âœ… ANTLR 4 (geraÃ§Ã£o de parsers)
âœ… JUnit 5 (testes)
âœ… Maven (build automation)
âœ… Java 17+ (linguagem de implementaÃ§Ã£o)



### Desafios Enfrentados

| Desafio                   | SoluÃ§Ã£o                                                 |
|---------------------------|---------------------------------------------------------|
| PrecedÃªncia de Operadores | Definir regras gramaticais corretas na gramÃ¡tica ANTLR  |
| Gerenciamento de Escopos  | Implementar pilha de escopos na tabela de sÃ­mbolos      |
| GeraÃ§Ã£o de RÃ³tulos        | Criar gerenciador de labels para estruturas de controle |
| OtimizaÃ§Ãµes               | Implementar passes de otimizaÃ§Ã£o separados e modulares  |
| Mensagens de Erro         | Capturar contexto (linha/coluna) e fornecer sugestÃµes   |

---

### PrÃ³ximos Passos (Futuro)

| Melhoria              | DescriÃ§Ã£o                                        |
|-----------------------|--------------------------------------------------|
| GeraÃ§Ã£o de Assembly   | Traduzir TAC para Assembly x86/ARM               |
| GeraÃ§Ã£o de ExecutÃ¡vel | Criar binÃ¡rio executÃ¡vel (.exe/.out)             |
| Suporte a FunÃ§Ãµes     | Implementar chamadas de funÃ§Ã£o e pilha           |
| Arrays                | Adicionar suporte a vetores e matrizes           |
| OtimizaÃ§Ãµes AvanÃ§adas | Loop unrolling, register allocation              |
| IDE/Editor            | Criar plugin para VSCode com syntax highlighting |

---

## ğŸ“Š Resumo Final

| Item                   | Status                        |
|------------------------|-------------------------------|
| GramÃ¡tica BNF Definida | âœ… Completa                   |
| Analisador LÃ©xico      | âœ… 40+ tokens                 |
| Analisador SintÃ¡tico   | âœ… AST gerada                 |
| Analisador SemÃ¢ntico   | âœ… Tabela de sÃ­mbolos + tipos |
| Gerador de CÃ³digo TAC  | âœ… 11 tipos de instruÃ§Ãµes     |
| OtimizaÃ§Ãµes            | âœ… 4 tÃ©cnicas                 |
| Testes UnitÃ¡rios       | âœ… 28 testes (100%)           |
| DocumentaÃ§Ã£o           | âœ… README + 5 entregas        |
| ApresentaÃ§Ã£o           | âœ… Preparada                  |
| PROJETO COMPLETO       | âœ… 100% CONCLUÃDO             |

---

## ğŸ“ HistÃ³rico de VersÃµes

| VersÃ£o | Data       | DescriÃ§Ã£o                          | Autor              |
|--------|------------|------------------------------------|--------------------|
| 1.0    | 14/01/2026 | GramÃ¡tica BNF definida             | Equipe Mini-Pascal |
| 2.0    | 21/01/2026 | Analisador lÃ©xico implementado     | Equipe Mini-Pascal |
| 3.0    | 28/01/2026 | Analisadores sintÃ¡tico e semÃ¢ntico | Equipe Mini-Pascal |
| 4.0    | 04/02/2026 | Gerador de cÃ³digo intermediÃ¡rio    | Equipe Mini-Pascal |
| 5.0    | 11/02/2026 | VersÃ£o final completa              | Equipe Mini-Pascal |

ğŸ‘¥ Autores
Enaldo Dantas  - jose.santos259@academico.ifs.edu.br
Agnaldo Neto   - jose.neto044@academico.ifs.edu.br
Vitorio Mota   - vitorio.mota085@academico.ifs.edu.br
Lucas Oliveira - lucas.oliveira031@academico.ifs.edu.br


ğŸ“ ContatoPara dÃºvidas sobre este projeto:
Email: jeds@outlook.com.br
GitHub: https://github.com/ifs2026/compilador-mini-pascal


ğŸ“š ReferÃªncias
AHO, Alfred V. et al. Compiladores: princÃ­pios, tÃ©cnicas e ferramentas. 2. ed. SÃ£o Paulo: Pearson Addison-Wesley, 2008. (Dragon Book)
PRICE, Ana Maria de Alencar; TOSCANI, SimÃ£o Sirineo. ImplementaÃ§Ã£o de linguagens de programaÃ§Ã£o: compiladores. 3. ed. Porto Alegre: Bookman, 2008.
PARR, Terence. The definitive ANTLR 4 reference. 2. ed. Raleigh: Pragmatic Bookshelf, 2013.
ANTLR Official Documentation: https://www.antlr.org/


ğŸ‰ PROJETO CONCLUÃDO COM SUCESSO! ğŸ‰
Desenvolvido para IFS Campus Itabaiana - 2025.2
Disciplina: LINGUAGENS FORMAIS, AUTÃ”MATOS E COMPILADORES

Agradecimentos especiais ao professor pela orientaÃ§Ã£o e aos colegas pelo apoio durante o desenvolvimento deste projeto acadÃªmico
