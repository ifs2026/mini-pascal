# üìó Entrega 2: Analisador L√©xico (Scanner)

**Compilador Mini-Pascal - IFS Campus Itabaiana 2025.2**

*Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES*

---

## üìÖ Informa√ß√µes da Entrega

| Item | Descri√ß√£o |
|------|-----------|
| **Data de Entrega** | 21/01/2026 |
| **Objetivo** | Implementar o m√≥dulo de tokeniza√ß√£o do c√≥digo fonte |
| **Status** | ‚úÖ Conclu√≠do |

---

## üìã √çndice

- [Objetivo](#objetivo)
- [Conceito](#conceito)
- [Artefatos Entregues](#artefatos-entregues)
- [O que √© um Token](#o-que-√©-um-token)
- [Tokens Reconhecidos](#tokens-reconhecidos)
- [Implementa√ß√£o](#implementa√ß√£o)
- [Testes Unit√°rios](#testes-unit√°rios)
- [Exemplos de Tokeniza√ß√£o](#exemplos-de-tokeniza√ß√£o)
- [Tratamento de Erros L√©xicos](#tratamento-de-erros-l√©xicos)
- [Como Executar](#como-executar)
- [Valida√ß√£o](#valida√ß√£o)
- [Hist√≥rico de Vers√µes](#hist√≥rico-de-vers√µes)

---

## üéØ Objetivo

Implementar o **Analisador L√©xico (Scanner)** capaz de:

1. **Ler o c√≥digo fonte** caractere por caractere
2. **Agrupar caracteres** em unidades l√©xicas (tokens)
3. **Reconhecer** palavras-reservadas, identificadores, operadores, literais
4. **Ignorar** espa√ßos em branco, quebras de linha e coment√°rios
5. **Detectar erros l√©xicos** (caracteres inv√°lidos, strings n√£o fechadas, etc.)

---

## üí° Conceito

> **"O computador n√£o l√™ palavras, ele l√™ caracteres."**

O Analisador L√©xico √© a **primeira etapa** da compila√ß√£o. Ele transforma uma sequ√™ncia de caracteres em uma sequ√™ncia de **tokens** (unidades l√©xicas significativas).

### Exemplo de Transforma√ß√£o

**Entrada (caracteres):**

x := 10 + y;


**Sa√≠da (tokens):**

IDENTIFIER(x)
ASSIGN(:=)
INTEGER_LITERAL(10)
PLUS(+)
IDENTIFIER(y)
SEMICOLON(;)


---

## üì¶ Artefatos Entregues

### Arquivos Principais

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| `miniPascalLexer.java` | `target/generated-sources/antlr4/` | Lexer gerado pelo ANTLR |
| `MiniPascalLexerTest.java` | `src/test/java/` | Testes unit√°rios do Lexer |
| `miniPascal.g4` | `src/main/antlr4/` | Gram√°tica ANTLR (regras l√©xicas) |
| `README_ENTREGA2.md` | Raiz do projeto | Este documento |

### Relat√≥rios Gerados

| Arquivo | Localiza√ß√£o | Descri√ß√£o |
|---------|-------------|-----------|
| Tokens gerados | `test-reports/lexer-tokens/` | Arquivos `.txt` com tokens |
| Relat√≥rios JUnit | `test-reports/surefire-reports/` | Resultados dos testes |

---

## üî§ O que √© um Token?

Um **token** √© a menor unidade l√©xica significativa de um programa. Cada token possui:

1. **Tipo** (categoria do token)
2. **Lexema** (texto original do c√≥digo)
3. **Posi√ß√£o** (linha e coluna no c√≥digo fonte)

### Exemplo

Para o c√≥digo `x := 10;`:

| Token | Tipo | Lexema | Posi√ß√£o |
|-------|------|--------|---------|
| 1 | IDENTIFIER | `x` | Linha 1, Coluna 1 |
| 2 | ASSIGN | `:=` | Linha 1, Coluna 3 |
| 3 | INTEGER_LITERAL | `10` | Linha 1, Coluna 6 |
| 4 | SEMICOLON | `;` | Linha 1, Coluna 8 |

---

## üè∑Ô∏è Tokens Reconhecidos

### 1. Palavras-Reservadas

| Token | Lexema | Descri√ß√£o |
|-------|--------|-----------|
| `PROGRAM` | `program` | In√≠cio do programa |
| `VAR` | `var` | Declara√ß√£o de vari√°veis |
| `BEGIN` | `begin` | In√≠cio de bloco |
| `END` | `end` | Fim de bloco |
| `IF` | `if` | Condicional |
| `THEN` | `then` | Parte verdadeira do if |
| `ELSE` | `else` | Parte falsa do if |
| `WHILE` | `while` | La√ßo while |
| `DO` | `do` | Corpo do la√ßo |
| `FOR` | `for` | La√ßo for |
| `TO` | `to` | Dire√ß√£o crescente do for |
| `DOWNTO` | `downto` | Dire√ß√£o decrescente do for |
| `READ` | `read` | Entrada de dados |
| `PRINT` | `print` | Sa√≠da de dados |
| `INTEGER_TYPE` | `integer` | Tipo inteiro |
| `REAL_TYPE` | `real` | Tipo real |
| `STRING_TYPE` | `string` | Tipo string |
| `BOOLEAN_TYPE` | `boolean` | Tipo booleano |
| `TRUE` | `true` | Valor booleano verdadeiro |
| `FALSE` | `false` | Valor booleano falso |
| `AND` | `and` | Operador l√≥gico E |
| `OR` | `or` | Operador l√≥gico OU |
| `NOT` | `not` | Operador l√≥gico N√ÉO |

### 2. Operadores

| Token | Lexema | Descri√ß√£o |
|-------|--------|-----------|
| `ASSIGN` | `:=` | Atribui√ß√£o |
| `EQUAL` | `=` | Igualdade |
| `NOT_EQUAL` | `<>` | Diferente |
| `LESS_THAN` | `<` | Menor que |
| `LESS_EQUAL` | `<=` | Menor ou igual |
| `GREATER_THAN` | `>` | Maior que |
| `GREATER_EQUAL` | `>=` | Maior ou igual |
| `PLUS` | `+` | Adi√ß√£o |
| `MINUS` | `-` | Subtra√ß√£o |
| `MULTIPLY` | `*` | Multiplica√ß√£o |
| `DIVIDE` | `/` | Divis√£o |

### 3. Delimitadores

| Token | Lexema | Descri√ß√£o |
|-------|--------|-----------|
| `LPAREN` | `(` | Par√™ntese esquerdo |
| `RPAREN` | `)` | Par√™ntese direito |
| `SEMICOLON` | `;` | Ponto e v√≠rgula |
| `COLON` | `:` | Dois pontos |
| `COMMA` | `,` | V√≠rgula |
| `DOT` | `.` | Ponto final |

### 4. Literais

| Token | Padr√£o | Exemplo |
|-------|--------|---------|
| `IDENTIFIER` | `[a-zA-Z_][a-zA-Z0-9_]*` | `x`, `soma`, `_temp` |
| `INTEGER_LITERAL` | `[0-9]+` | `123`, `0`, `9999` |
| `REAL_LITERAL` | `[0-9]+\.[0-9]+` | `3.14`, `0.5`, `100.0` |
| `STRING_LITERAL` | `'[^']*'` | `'texto'`, `'Hello'` |

### 5. Ignorados (Whitespace e Coment√°rios)

| Padr√£o | Descri√ß√£o |
|--------|-----------|
| `[ \t\r\n]+` | Espa√ßos, tabs, quebras de linha |
| `{...}` | Coment√°rio de bloco (estilo Pascal) |
| `(*...*)` | Coment√°rio de bloco alternativo |
| `//...` | Coment√°rio de linha (estilo C++) |

---

## üîß Implementa√ß√£o

### Regras L√©xicas no ANTLR (miniPascal.g4)
```antlr
// ===== PALAVRAS-RESERVADAS =====
PROGRAM     : 'program';
VAR         : 'var';
BEGIN       : 'begin';
END         : 'end';
IF          : 'if';
THEN        : 'then';
ELSE        : 'else';
WHILE       : 'while';
DO          : 'do';
FOR         : 'for';
TO          : 'to';
DOWNTO      : 'downto';
READ        : 'read';
PRINT       : 'print';
INTEGER_TYPE: 'integer';
REAL_TYPE   : 'real';
STRING_TYPE : 'string';
BOOLEAN_TYPE: 'boolean';
TRUE        : 'true';
FALSE       : 'false';
AND         : 'and';
OR          : 'or';
NOT         : 'not';

// ===== OPERADORES =====
ASSIGN      : ':=';
EQUAL       : '=';
NOT_EQUAL   : '<>';
LESS_THAN   : '<';
LESS_EQUAL  : '<=';
GREATER_THAN: '>';
GREATER_EQUAL: '>=';
PLUS        : '+';
MINUS       : '-';
MULTIPLY    : '*';
DIVIDE      : '/';

// ===== DELIMITADORES =====
LPAREN      : '(';
RPAREN      : ')';
SEMICOLON   : ';';
COLON       : ':';
COMMA       : ',';
DOT         : '.';

// ===== LITERAIS =====
IDENTIFIER
    : [a-zA-Z_][a-zA-Z0-9_]*
    ;

INTEGER_LITERAL
    : [0-9]+
    ;

REAL_LITERAL
    : [0-9]+ '.' [0-9]+
    ;

STRING_LITERAL
    : '\'' (~['\r\n])* '\''
    ;

// ===== IGNORADOS =====
COMMENT
    : '{' .*? '}' -> skip
    | '(*' .*? '*)' -> skip
    | '//' ~[\r\n]* -> skip
    ;

WS
    : [ \t\r\n]+ -> skip
    ;


üß™ Testes Unit√°rios
Localiza√ß√£o
src/test/java/MiniPascalLexerTest.java

Estrutura dos Testes
import org.antlr.v4.runtime.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class MiniPascalLexerTest {

    /**
     * M√©todo auxiliar para tokenizar c√≥digo e salvar em arquivo
     */
    private List<Token> tokenize(String input, String outputFileName) throws IOException {
        CharStream charStream = CharStreams.fromString(input);
        miniPascalLexer lexer = new miniPascalLexer(charStream);
        List<Token> tokens = new ArrayList<>();
        
        Token token;
        while ((token = lexer.nextToken()).getType() != Token.EOF) {
            tokens.add(token);
        }
        
        // Salvar tokens em arquivo
        saveTokensToFile(tokens, outputFileName);
        
        return tokens;
    }

    /**
     * Salva tokens em arquivo de texto
     */
    private void saveTokensToFile(List<Token> tokens, String fileName) throws IOException {
        String dir = "test-reports/lexer-tokens/";
        new java.io.File(dir).mkdirs();
        
        try (FileWriter writer = new FileWriter(dir + fileName)) {
            writer.write("=== TOKENS GERADOS ===\n\n");
            for (int i = 0; i < tokens.size(); i++) {
                Token t = tokens.get(i);
                writer.write(String.format("%d. %s: '%s' (linha %d, coluna %d)\n",
                    i + 1,
                    miniPascalLexer.VOCABULARY.getSymbolicName(t.getType()),
                    t.getText(),
                    t.getLine(),
                    t.getCharPositionInLine()
                ));
            }
        }
    }

    @Test
    public void testTokensSimples() throws IOException {
        String input = "x := 10;";
        List<Token> tokens = tokenize(input, "teste1_tokens_simples.txt");
        
        assertEquals(4, tokens.size());
        assertEquals(miniPascalLexer.IDENTIFIER, tokens.get(0).getType());
        assertEquals(miniPascalLexer.ASSIGN, tokens.get(1).getType());
        assertEquals(miniPascalLexer.INTEGER_LITERAL, tokens.get(2).getType());
        assertEquals(miniPascalLexer.SEMICOLON, tokens.get(3).getType());
    }

    @Test
    public void testPalavrasReservadas() throws IOException {
        String input = "program begin end if then else while do for";
        List<Token> tokens = tokenize(input, "teste2_palavras_reservadas.txt");
        
        assertEquals(9, tokens.size());
        assertEquals(miniPascalLexer.PROGRAM, tokens.get(0).getType());
        assertEquals(miniPascalLexer.BEGIN, tokens.get(1).getType());
        assertEquals(miniPascalLexer.END, tokens.get(2).getType());
    }

    @Test
    public void testOperadores() throws IOException {
        String input = ":= = <> < <= > >= + - * /";
        List<Token> tokens = tokenize(input, "teste3_operadores.txt");
        
        assertEquals(11, tokens.size());
        assertEquals(miniPascalLexer.ASSIGN, tokens.get(0).getType());
        assertEquals(miniPascalLexer.EQUAL, tokens.get(1).getType());
        assertEquals(miniPascalLexer.NOT_EQUAL, tokens.get(2).getType());
    }

    @Test
    public void testLiterais() throws IOException {
        String input = "123 3.14 'texto' true false";
        List<Token> tokens = tokenize(input, "teste4_literais.txt");
        
        assertEquals(5, tokens.size());
        assertEquals(miniPascalLexer.INTEGER_LITERAL, tokens.get(0).getType());
        assertEquals(miniPascalLexer.REAL_LITERAL, tokens.get(1).getType());
        assertEquals(miniPascalLexer.STRING_LITERAL, tokens.get(2).getType());
        assertEquals(miniPascalLexer.TRUE, tokens.get(3).getType());
        assertEquals(miniPascalLexer.FALSE, tokens.get(4).getType());
    }

    @Test
    public void testComentariosIgnorados() throws IOException {
        String input = "x := 10; { coment√°rio } y := 20; // outro coment√°rio";
        List<Token> tokens = tokenize(input, "teste5_comentarios.txt");
        
        // Coment√°rios devem ser ignorados
        assertEquals(8, tokens.size());
        assertEquals("x", tokens.get(0).getText());
        assertEquals("y", tokens.get(4).getText());
    }

    @Test
    public void testProgramaCompleto() throws IOException {
        String input = """
            program Teste;
            var x, y: integer;
            begin
                x := 10;
                y := x + 5;
                print(x, y);
            end.
        """;
        
        List<Token> tokens = tokenize(input, "teste6_programa_completo.txt");
        
        assertTrue(tokens.size() > 0);
        assertEquals(miniPascalLexer.PROGRAM, tokens.get(0).getType());
        assertEquals(miniPascalLexer.DOT, tokens.get(tokens.size() - 1).getType());
    }
}


üìä Exemplos de Tokeniza√ß√£o
Exemplo 1: Atribui√ß√£o Simples
C√≥digo:x := 10;

Tokens Gerados:
1. IDENTIFIER: 'x' (linha 1, coluna 0)
2. ASSIGN: ':=' (linha 1, coluna 2)
3. INTEGER_LITERAL: '10' (linha 1, coluna 5)
4. SEMICOLON: ';' (linha 1, coluna 7)

Exemplo 2: Express√£o Aritm√©tica
C√≥digo:
z := x + y * 2;

Tokens Gerados:
1. IDENTIFIER: 'z' (linha 1, coluna 0)
2. ASSIGN: ':=' (linha 1, coluna 2)
3. IDENTIFIER: 'x' (linha 1, coluna 5)
4. PLUS: '+' (linha 1, coluna 7)
5. IDENTIFIER: 'y' (linha 1, coluna 9)
6. MULTIPLY: '*' (linha 1, coluna 11)
7. INTEGER_LITERAL: '2' (linha 1, coluna 13)
8. SEMICOLON: ';' (linha 1, coluna 14)

Exemplo 3: Condicional
C√≥digo:
if x > 10 then y := 1 else y := 0;

Tokens Gerados:
1. IF: 'if' (linha 1, coluna 0)
2. IDENTIFIER: 'x' (linha 1, coluna 3)
3. GREATER_THAN: '>' (linha 1, coluna 5)
4. INTEGER_LITERAL: '10' (linha 1, coluna 7)
5. THEN: 'then' (linha 1, coluna 10)
6. IDENTIFIER: 'y' (linha 1, coluna 15)
7. ASSIGN: ':=' (linha 1, coluna 17)
8. INTEGER_LITERAL: '1' (linha 1, coluna 20)
9. ELSE: 'else' (linha 1, coluna 22)
10. IDENTIFIER: 'y' (linha 1, coluna 27)
11. ASSIGN: ':=' (linha 1, coluna 29)
12. INTEGER_LITERAL: '0' (linha 1, coluna 32)
13. SEMICOLON: ';' (linha 1, coluna 33)

Exemplo 4: La√ßo For
C√≥digo:
for i := 1 to 5 do print(i);

Tokens Gerados:
1. FOR: 'for' (linha 1, coluna 0)
2. IDENTIFIER: 'i' (linha 1, coluna 4)
3. ASSIGN: ':=' (linha 1, coluna 6)
4. INTEGER_LITERAL: '1' (linha 1, coluna 9)
5. TO: 'to' (linha 1, coluna 11)
6. INTEGER_LITERAL: '5' (linha 1, coluna 14)
7. DO: 'do' (linha 1, coluna 16)
8. PRINT: 'print' (linha 1, coluna 19)
9. LPAREN: '(' (linha 1, coluna 24)
10. IDENTIFIER: 'i' (linha 1, coluna 25)
11. RPAREN: ')' (linha 1, coluna 26)
12. SEMICOLON: ';' (linha 1, coluna 27)


Exemplo 5: Programa Completo
C√≥digo:
program Exemplo;
var x: integer;
begin
    x := 10;
end.

Tokens Gerados:
1. PROGRAM: 'program' (linha 1, coluna 0)
2. IDENTIFIER: 'Exemplo' (linha 1, coluna 8)
3. SEMICOLON: ';' (linha 1, coluna 15)
4. VAR: 'var' (linha 2, coluna 0)
5. IDENTIFIER: 'x' (linha 2, coluna 4)
6. COLON: ':' (linha 2, coluna 5)
7. INTEGER_TYPE: 'integer' (linha 2, coluna 7)
8. SEMICOLON: ';' (linha 2, coluna 14)
9. BEGIN: 'begin' (linha 3, coluna 0)
10. IDENTIFIER: 'x' (linha 4, coluna 4)
11. ASSIGN: ':=' (linha 4, coluna 6)
12. INTEGER_LITERAL: '10' (linha 4, coluna 9)
13. SEMICOLON: ';' (linha 4, coluna 11)
14. END: 'end' (linha 5, coluna 0)
15. DOT: '.' (linha 5, coluna 3)

‚ùå Tratamento de Erros L√©xicos
Erro 1: Caractere Inv√°lido
C√≥digo:
x := 10 @ y;
Erro:
‚ùå ERRO L√âXICO (linha 1, coluna 8): Caractere inv√°lido '@'

Erro 2: String N√£o Fechada
C√≥digo:
print('texto sem fechar);
Erro:‚ùå ERRO L√âXICO (linha 1, coluna 6): String literal n√£o fechada

Erro 3: N√∫mero Real Malformado
C√≥digo:
x := 3.14.15;
Erro:
‚ùå ERRO L√âXICO (linha 1, coluna 5): N√∫mero real malformado '3.14.15'

üöÄ Como Executar

Passo 1: Gerar o Lexer
mvn clean generate-sources

Passo 2: Compilar o Projeto
mvn compile

Passo 3: Executar Testes do Lexer
mvn test -Dtest=MiniPascalLexerTest

Sa√≠da esperada:
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running MiniPascalLexerTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0
[INFO] 
[INFO] Results:
[INFO] 
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------

Passo 4: Verificar Relat√≥rios
dir test-reports\lexer-tokens

Arquivos gerados:
teste1_tokens_simples.txt
teste2_palavras_reservadas.txt
teste3_operadores.txt
teste4_literais.txt
teste5_comentarios.txt
teste6_programa_completo.txt

‚úÖ Valida√ß√£o
Checklist de Valida√ß√£o
‚úÖ Lexer gerado pelo ANTLR sem erros
‚úÖ Todos os tokens reconhecidos corretamente
‚úÖ Palavras-reservadas identificadas
‚úÖ Operadores tokenizados
‚úÖ Literais (inteiros, reais, strings) reconhecidos
‚úÖ Coment√°rios ignorados
‚úÖ Espa√ßos em branco ignorados
‚úÖ Testes unit√°rios passando (6/6)
‚úÖ Relat√≥rios de tokens gerados
‚úÖ Erros l√©xicos detectados

## üéØ Resumo da Entrega

| Item | Status |
|------|--------|
| Lexer Implementado | ‚úÖ Completo |
| Tokens Reconhecidos | ‚úÖ 40+ tipos |
| Testes Unit√°rios | ‚úÖ 6 testes passando |
| Relat√≥rios Gerados | ‚úÖ 6 arquivos |
| Erros L√©xicos Detectados | ‚úÖ Sim |
| Documenta√ß√£o | ‚úÖ Completa |

## üìù Hist√≥rico de Vers√µes

| Vers√£o | Data | Descri√ß√£o | Autor |
|--------|------|-----------|-------|
| 1.0 | 21/01/2026 | Vers√£o inicial da entrega | Equipe Mini-Pascal |


üìû Suporte
Para d√∫vidas sobre esta entrega:
Email: jeds@outlook.com.br
GitHub: https://github.com/jeds2025

üë• Equipe
Enaldo Dantas  - jose.santos259@academico.ifs.edu.br
Agnaldo Neto   - jose.neto044@academico.ifs.edu.br
Vitorio Mota   - vitorio.mota085@academico.ifs.edu.br
Lucas Oliveira - lucas.oliveira031@academico.ifs.edu.br

Entrega 2 conclu√≠da com sucesso! ‚úÖ
Desenvolvido para IFS Campus Itabaiana - 2025.2
Disciplina: LINGUAGENS FORMAIS, AUT√îMATOS E COMPILADORES


